{"meta":{"title":"Juuichi","subtitle":"i love u 3000 times","description":"To record my learning about CS, and some miscellaneous notes","author":"Juuichi","url":"http://zhang2514yuchi.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-20T16:46:40.679Z","updated":"2022-02-20T16:46:40.669Z","comments":true,"path":"about/index.html","permalink":"http://zhang2514yuchi.github.io/about/index.html","excerpt":"","text":"我是 Juuichi 目前就读于 哈尔滨工程大学 退役ACMer"}],"posts":[{"title":"数据结构部分模版","slug":"数据结构","date":"2022-02-21T01:26:34.000Z","updated":"2022-02-21T03:22:21.637Z","comments":true,"path":"2022/02/21/数据结构/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"树状数组脑子里画出这个图 1.区间查&#x2F;单点改123456789101112131415int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125; 2.差分实现区间改&#x2F;单点查1234567891011121314151617181920212223242526272829303132333435363738int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123;cin&gt;&gt;a[i];add(i,a[i]-a[i-1]);&#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x; if(x==1) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; add(l,k),add(r+1,-k); &#125; else &#123; cin&gt;&gt;k; cout&lt;&lt;sum(k)&lt;&lt;endl; &#125; &#125; return 0; &#125; 3.差分实现区间改&#x2F;区间查$$sum[i]&#x3D;\\sum_{j&#x3D;1}^i c[j] \\times(i-j+1)\\sum[i]&#x3D;(i+1) \\times \\sum_{j&#x3D;1}^i c[j] -\\sum_{j&#x3D;1}^i c[j] \\times j$$ 123456789101112131415161718192021222324252627282930313233343536373839404142int n,m;int d1[Max],d2[Max],a[Max],b[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int *c,int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int *c,int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;inline int f(int x)&#123; return b[x]+(x+1)*sum(d1,x)-sum(d2,x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123; cin&gt;&gt;a[i]; b[i]=b[i-1]+a[i]; &#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x&gt;&gt;l&gt;&gt;r; if(x==1) &#123; cin&gt;&gt;k; add(d1,l,k),add(d1,r+1,-k),add(d2,l,k*l),add(d2,r+1,-k*(r+1)); &#125; else cout&lt;&lt;f(r)-f(l-1)&lt;&lt;endl; &#125; return 0; &#125; 4.最值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int m,n;int a[Max],c[Max],MAX[Max];char ch;inline int lowbit(int x)&#123;return x&amp;-x;&#125;void add(int p,int k)&#123; a[p]=k; while(p&lt;=n) &#123; c[p]=max(c[p],k); int t=lowbit(p); for(int i=1;i&lt;t;i*=2) c[p]=max(c[p],c[p-i]); p+=lowbit(p); &#125;&#125;int query(int l,int r)&#123; int ans=0; while(1) &#123; ans=max(ans,a[r]); if(r==l) break; for(r-=1;r-l&gt;=lowbit(r);r-=lowbit(r)) ans=max(ans,c[r]); &#125; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; pos(i,1,n) add(i,a[i]); int y,x; pos(i,1,m) &#123; ch=getchar(); while(ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=getchar(); scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); if(ch==&#x27;Q&#x27;) cout&lt;&lt;query(x,y)&lt;&lt;endl; else &#123; if(y&lt;=a[x]) continue; add(x,y); &#125; &#125; return 0;&#125; 线段树123#define mid (s+((t-s)&gt;&gt;1))#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1) 以下代码中$s,t$代表当前区间$l,r$代表询问区间 区间修改，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=(t-s+1)*c; b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 单点修改，区间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445int n,m;int a[Max],d[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; // pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int x,int s,int t,int p,int c)&#123; if(s==t) &#123; d[p]+=c; return; &#125; // pushdown(s,t,p); if(x&lt;=mid) update(x,s,mid,ls,c); if(x&gt;mid) update(x,mid+1,t,rs,c); pushup(p);&#125; 单点查询，区间修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int x,int s,int t,int p)&#123; if(s==t) &#123; return d[p]; &#125; pushdown(s,t,p); if(x&lt;=mid) return query(x,s,mid,ls); if(x&gt;mid) return query(x,mid+1,t,rs);&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=c*(t-s+1); b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 主席树$\\$ 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int cnt,n,m;int a[Max],root[Max];struct Tree&#123; int l,r,val;&#125;tree[Max];int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123; tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123; tree[p].val=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query(int p,int s,int t,int x)&#123; if(s==t) return tree[p].val; if(x&lt;=mid) return query(tree[p].l,s,mid,x); else return query(tree[p].r,mid+1,t,x);&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; root[0]=build(0,1,n); return 0;&#125; 区间第k小123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; tree[cnt].val++; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123;// tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123;// tree[p].val+=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query1(int p,int q,int s,int t,int k)&#123; int x=tree[tree[p].l].val-tree[tree[q].l].val; if(s==t) return b[s]; if(x&gt;=k) return query1(tree[p].l,tree[q].l,s,mid,k); else return query1(tree[p].r,tree[q].r,mid+1,t,k-x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b+1,b+1+n); int nn=unique(b+1,b+1+n)-b-1; rt[0]=build(0,1,nn); for(int i=1;i&lt;=n;i++) &#123; int x=lower_bound(b+1,b+1+nn,a[i])-b; rt[i]=update(rt[i-1],1,nn,x,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; cout&lt;&lt;query1(rt[y],rt[x-1],1,nn,z)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"newpapername","slug":"介绍","date":"2022-02-20T14:46:56.000Z","updated":"2022-02-20T14:50:12.977Z","comments":true,"path":"2022/02/20/介绍/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/20/%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"hello 我叫张宇驰 忍不了在博客园的那个了 在网上找了个教程自己搭一个hexo试试","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]}