{"meta":{"title":"Juuichi","subtitle":"张宇驰的blog","description":"记录计算机相关知识,算法刷题笔记等","author":"Juuichi","url":"http://zhang2514yuchi.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-20T16:46:40.679Z","updated":"2022-02-20T16:46:40.669Z","comments":true,"path":"about/index.html","permalink":"http://zhang2514yuchi.github.io/about/index.html","excerpt":"","text":"我是 Juuichi 目前就读于 哈尔滨工程大学 退役ACMer"},{"title":"标签","date":"2022-02-21T04:33:30.000Z","updated":"2022-02-21T04:48:35.569Z","comments":true,"path":"tags/index.html","permalink":"http://zhang2514yuchi.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-21T04:34:53.000Z","updated":"2022-02-21T04:48:25.495Z","comments":true,"path":"categories/index.html","permalink":"http://zhang2514yuchi.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"P1040 [NOIP2003 提高组] 加分二叉树","slug":"P1040","date":"2022-03-14T11:20:07.000Z","updated":"2022-03-14T11:21:43.278Z","comments":true,"path":"2022/03/14/P1040/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/14/P1040/","excerpt":"一道区间dp 重点关注路径标记","text":"一道区间dp 重点关注路径标记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int Max=1e3+10;int n;int a[Max],dp[Max][Max],lt[Max],rt[Max],d[Max][Max],vis[Max];void dfs(int x)&#123; if(x==-1) return; cout&lt;&lt;x&lt;&lt;&quot; &quot;; dfs(lt[x]); dfs(rt[x]); return;&#125;void print(int l,int r) &#123; if(l&gt;r)return; cout&lt;&lt;d[l][r]&lt;&lt;&quot; &quot;; if (l == r)return; print(l, d[l][r] - 1); print(d[l][r]+1,r);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; dp[i][i]=a[i]; d[i][i]=i; &#125; for(int l=2;l&lt;=n;l++) &#123; for(int s=1;s&lt;=n-l+1;s++) &#123; int t=s+l-1; if(dp[s][t-1]+dp[t][t]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][t-1]+dp[t][t]; d[s][t]=t; &#125; if(dp[s][s]+dp[s+1][t]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][s]+dp[s+1][t]; d[s][t]=s; &#125; for(int k=s+1;k&lt;=t-1;k++) &#123; if(dp[s][k-1]*dp[k+1][t]+a[k]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][k-1]*dp[k+1][t]+a[k]; d[s][t]=k; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; print(1,n); return 0;&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"高精模版小结","slug":"高精","date":"2022-03-14T09:39:14.000Z","updated":"2022-03-14T09:42:26.741Z","comments":true,"path":"2022/03/14/高精/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/14/%E9%AB%98%E7%B2%BE/","excerpt":"总结一下常用高精度 $高精+高精$ $高精\\times单精$ $\\max(高精,高精)$","text":"总结一下常用高精度 $高精+高精$ $高精\\times单精$ $\\max(高精,高精)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct HP&#123; int p[505],len; HP() &#123; memset(p,0,sizeof(p)); len=0; &#125; void print() &#123; cout&lt;&lt;p[len]; for(int i=len-1;i&gt;=1;i--) &#123; if(p[i]==0) &#123;cout&lt;&lt;&quot;0000&quot;;continue;&#125; for(int j=10;j*p[i]&lt;M;j*=10) cout&lt;&lt;&quot;0&quot;; cout&lt;&lt;p[i]; &#125; return; &#125;&#125;dp[Max][Max],b[110],res;HP operator + (const HP &amp;a,const HP &amp;b)&#123; int x=0; HP c; if(a.len&gt;b.len) c.len=a.len; else c.len=b.len; // c.len=max(a.len,b.len); for(int i=1;i&lt;=c.len;i++) &#123; c.p[i]=a.p[i]+b.p[i]+x; x=c.p[i]/M; c.p[i]%=M; &#125; if(x&gt;0) c.p[++c.len]=x; return c;&#125;HP operator * (const HP &amp;a,const int &amp;b)&#123; int x=0; HP c; c.len=a.len; for(int i=1;i&lt;=c.len;i++) &#123; c.p[i]=a.p[i]*b+x; x=c.p[i]/M; c.p[i]%=M; &#125; if(x&gt;0) c.p[++c.len]=x; return c;&#125;HP max(const HP &amp;a,const HP &amp;b)&#123; if(a.len&gt;b.len) &#123; return a; &#125; else if(a.len&lt;b.len) &#123; return b; &#125; else &#123; for(int i=a.len;i&gt;=1;i--) &#123; if(a.p[i]&gt;b.p[i]) return a; else if(a.p[i]&lt;b.p[i]) return b; else continue; &#125; return a; &#125;&#125;","categories":[],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://zhang2514yuchi.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"线代复习-3-矩阵的基本概念与运算","slug":"线代3","date":"2022-03-13T12:54:31.000Z","updated":"2022-03-14T03:42:22.441Z","comments":true,"path":"2022/03/13/线代3/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/13/%E7%BA%BF%E4%BB%A33/","excerpt":"矩阵的基本概念与运算","text":"矩阵的基本概念与运算 1.$AB&#x3D;BC,A\\ne0 \\Rightarrow A(B-C)&#x3D;0$ ​ $ \\nRightarrow B&#x3D;C$ 2.方阵乘积的行列式 ​ 设$A,B$是同阶方阵，则$|AB|&#x3D;|A||B|.$ 3.逆矩阵的性质 ​ 设$A,B$是同阶可逆矩阵，则 ​ (1) $AB$也可逆，且$(AB)^{-1}&#x3D;B^{-1}A^{-1}$ ​ (2)$A^T$也可逆，且$(A^T)^{-1}&#x3D;(A^{-1})^T$ 4.分块矩阵的逆，若$A,B$均是可逆方针，则： 5.求方阵的幂 (1)通过直接或者拆成–&gt;列$\\times$行 ，来凑前后两项为常数或单位矩阵 (2)算出前几次幂（2或3）可能会出现周期或者常数 (3)拆成$A+E$的形式，然后根据二项式定理展开 6.*[错题本] $A,B$是n阶方阵，满足$AB&#x3D;A-B$，证明：$AB&#x3D;BA.$ 7.*[错题本] 证明充分必要条件时，分两步：充分性和必要性 8.若$E+A$是可逆矩阵，则有$(E-A)(E+A)^{-1}&#x3D;(E+A)^{-1}(E-A)$ 即$(E+A)^{-1}$和$(E-A)$可交换 9.*[错题本] 设","categories":[],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P1156","slug":"P1156","date":"2022-03-10T03:32:52.000Z","updated":"2022-03-10T03:45:39.844Z","comments":true,"path":"2022/03/10/P1156/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/10/P1156/","excerpt":"一道背包问题","text":"一道背包问题 一开始想的 1234if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h);if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h); if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); if(dp[i][j]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; 看了下别人的类似思路 1234567891011if(j-x&lt;0) continue;dp[i][j-x]=max(dp[i][j-x],dp[i-1][j]+a[i].h);if(dp[i][j-x]&gt;=d)&#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0;&#125;if(j-x+a[i].f&lt;=10010)&#123; dp[i][j-x+a[i].f]=max(dp[i][j-x+a[i].f],dp[i-1][j]);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j-x&lt;0) continue; dp[i][j-x]=max(dp[i][j-x],dp[i-1][j]+a[i].h); if(dp[i][j-x]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; if(j-x+a[i].f&lt;=10010) &#123; dp[i][j-x+a[i].f]=max(dp[i][j-x+a[i].f],dp[i-1][j]); &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; 在我的思路基础上只多加了一个限制条件 1234if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h);if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010 &amp;&amp; j-a[i].f&gt;=0) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h); if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010 &amp;&amp; j-a[i].f&gt;=0) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); if(dp[i][j]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; 没想清楚限制条件，呜呜","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"CSP-202012 刷题记录","slug":"csp202012","date":"2022-03-07T09:17:44.000Z","updated":"2022-03-10T04:12:39.514Z","comments":true,"path":"2022/03/07/csp202012/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/07/csp202012/","excerpt":"总得分：405","text":"总得分：405 第三题得分：80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376#include&lt;bits/stdc++.h&gt;#define int long long using namespace std;const int Max=4e6+10;bool tr[Max];int siz[Max];int pre[Max];//tr==1代表是文件int cnt=0,fl=0;struct node&#123; int mulusiz,houdaisiz; int nowmulu,nowhoudai; set&lt;string&gt;st; map&lt;string,int&gt;mp;&#125;ml[Max];int read1(string x)&#123; int len=x.length(); for(int i=1;i&lt;len;i++) &#123; if(x[i]==&#x27;/&#x27;) &#123; return i; &#125; &#125; return len-1;&#125;bool check(string x,int y,int z)&#123; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; //y是当前目录，s1是当前要访问的东西 if(ml[y].st.find(s1)!=ml[y].st.end())//找到 &#123; int now=ml[y].mp[s1]; if(s2==&quot;&quot;) &#123; if(tr[now]) &#123; int z1=z-siz[now]; if(ml[y].mulusiz-ml[y].nowmulu&gt;=z1 &amp;&amp; ml[y].houdaisiz-ml[y].nowhoudai&gt;=z1) &#123; ++cnt; ml[y].mp[s1]=cnt; tr[cnt]=1; siz[cnt]=z; ml[y].nowmulu+=z1; int k=y; while(k!=-1) &#123; ml[k].nowhoudai+=z1; k=pre[k]; &#125; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; if(tr[now]) &#123; return 0; &#125; else &#123; if( ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; pre[now]=y; return check(s2,now,z); &#125; else &#123; return 0; &#125; &#125; &#125; &#125; else &#123; if(s2==&quot;&quot;) &#123; if(ml[y].mulusiz-ml[y].nowmulu&gt;=z &amp;&amp; ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; ++cnt; ml[y].st.insert(s1); ml[y].mp[s1]=cnt; tr[cnt]=1; siz[cnt]=z; ml[y].nowmulu+=z; int k=y; while(k!=-1) &#123; ml[k].nowhoudai+=z; k=pre[k]; &#125; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; if( ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; ++cnt; ml[y].st.insert(s1); ml[y].mp[s1]=cnt; tr[cnt]=0; ml[cnt].houdaisiz=2e18; ml[cnt].mulusiz=2e18; ml[cnt].nowhoudai=0; ml[cnt].nowmulu=0; pre[cnt]=y; return check(s2,cnt,z); &#125; else &#123; return 0; &#125; &#125; &#125; &#125;void shanchu(string x,int y)&#123; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; if(ml[y].st.find(s1)!=ml[y].st.end())//找到了 &#123; if(s2==&quot;&quot;)//叶子 &#123; if(tr[ml[y].mp[s1]])//文件 &#123; ml[y].st.erase(s1); int k=siz[ml[y].mp[s1]]; ml[y].mp[s1]=0; int i=y; ml[y].nowmulu-=k; while(i!=-1) &#123; ml[i].nowhoudai-=k; i=pre[i]; &#125; return; &#125; else &#123; ml[y].st.erase(s1); int k=ml[ml[y].mp[s1]].nowhoudai; ml[y].mp[s1]=0; int i=y; while(i!=-1) &#123; ml[i].nowhoudai-=k; i=pre[i]; &#125; return; &#125; &#125; else &#123; if(tr[ml[y].mp[s1]]) &#123; return; &#125; else &#123; pre[ml[y].mp[s1]]=y; shanchu(s2,ml[y].mp[s1]); return; &#125; &#125; &#125; else &#123; return; &#125;&#125;bool shezhi(string x,int y,int ld,int lr)&#123; if(x==&quot;/&quot;) &#123; if(ml[0].nowmulu&gt;ld||ml[0].nowhoudai&gt;lr) &#123; return 0; &#125; else &#123; ml[0].mulusiz=ld; ml[0].houdaisiz=lr; return 1; &#125; &#125; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; if(ml[y].st.find(s1)!=ml[y].st.end())//找到了 &#123; if(s2==&quot;&quot;)//叶子 &#123; if(tr[ml[y].mp[s1]])//文件 &#123; return 0; &#125; else &#123; if(ml[ml[y].mp[s1]].nowmulu&gt;ld||ml[ml[y].mp[s1]].nowhoudai&gt;lr) &#123; return 0; &#125; else &#123; ml[ml[y].mp[s1]].mulusiz=ld; ml[ml[y].mp[s1]].houdaisiz=lr; return 1; &#125; &#125; &#125; else &#123; if(tr[ml[y].mp[s1]]) &#123; return 0; &#125; else &#123; return shezhi(s2,ml[y].mp[s1],ld,lr); &#125; &#125; &#125; else &#123; return 0; &#125;&#125;signed main()&#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n; cin&gt;&gt;n; ml[0].mulusiz=2e18; ml[0].houdaisiz=2e18; ml[0].nowhoudai=0; ml[0].nowmulu=0; pre[0]=-1; for(int i=1;i&lt;=n;i++) &#123; char c; string s1; c=getchar(); while(c&lt;&#x27;A&#x27;||c&gt;&#x27;Z&#x27;) c=getchar(); if(c==&#x27;C&#x27;) &#123; int g; cin&gt;&gt;s1&gt;&gt;g; if(check(s1,0,g)) &#123; cout&lt;&lt;&quot;Y\\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;N\\n&quot;; &#125; &#125; else if(c==&#x27;R&#x27;) &#123; cin&gt;&gt;s1; fl=0; shanchu(s1,0); cout&lt;&lt;&quot;Y\\n&quot;; &#125; else if(c==&#x27;Q&#x27;) &#123; int ld,lr; cin&gt;&gt;s1&gt;&gt;ld&gt;&gt;lr; if(ld==0) ld=2e18; if(lr==0) lr=2e18; if(shezhi(s1,0,ld,lr)) &#123; cout&lt;&lt;&quot;Y\\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;N\\n&quot;; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125; 第四题得分：65 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;int n,m,k;int b[110][20];int cnt=0,h[1000],ans=0,mx=0;struct Edge&#123; int to,nxt,l;&#125;e[2000];void add(int u,int v,int w)&#123; e[++cnt].to=v; e[cnt].nxt=h[u]; e[cnt].l=w; h[u]=cnt;&#125;bool dfs(int u,int fa,int k,int dep)&#123; int tr=b[u][k]; for(int i=h[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==fa) continue; if(dfs(v,u,k,dep+e[i].l)) &#123; tr=1; ans+=e[i].l*2; &#125; &#125; if(tr) &#123; mx=max(mx,dep); return 1; &#125; else return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=k;j++) cin&gt;&gt;b[i][j]; &#125; for(int i=1;i&lt;n;i++) &#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; add(u,v,w); add(v,u,w); &#125; int tmp=0; for(int i=1;i&lt;=k;i++) &#123; int res=inf; for(int j=1;j&lt;=n;j++) &#123; ans=0,mx=0; dfs(j,0,i,0); res=min(res,ans-mx); &#125; tmp=max(tmp,res); &#125; cout&lt;&lt;tmp; return 0;&#125; 第五题得分：60 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include&lt;bits/stdc++.h&gt;#define int long long #define mid ((s+t)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1)using namespace std;const int Max=1e5+10;const int M=1e9+7;int n,m;struct node&#123; int x,y,z;&#125;d[Max*4],b[Max*4],a[Max],b1[Max*4];void add(int p,int k,int s,int t,int k1)&#123; if(k1==1) &#123; d[p].x=(d[p].x+k%M*(t-s+1)%M)%M; b[p].x=(b[p].x+k%M)%M; &#125; if(k1==2) &#123; d[p].y=(d[p].y+k%M*(t-s+1)%M)%M; b[p].y=(b[p].y+k%M)%M; &#125; if(k1==3) &#123; d[p].z=(d[p].z+k%M*(t-s+1)%M)%M; b[p].z=(b[p].z+k%M)%M; &#125; return;&#125;void mul(int p,int k,int s,int t,int k1)&#123; if(k1==1) &#123; d[p].x=k*d[p].x%M; b[p].x=k*b[p].x%M; b1[p].x=k*b1[p].x%M; &#125; if(k1==2) &#123; d[p].y=k*d[p].y%M; b[p].y=k*b[p].y%M; b1[p].y=k*b1[p].y%M; &#125; if(k1==3) &#123; d[p].z=k*d[p].z%M; b[p].z=k*b[p].z%M; b1[p].z=k*b1[p].z%M; &#125; return;&#125;void pushdown(int p,int s,int t,int k)&#123; if(k==1) &#123; d[ls].x=(d[ls].x*b1[p].x%M+(mid-s+1)%M*b[p].x%M)%M; d[rs].x=(d[rs].x*b1[p].x%M+(t-mid)%M*b[p].x%M)%M; b1[ls].x=(b1[ls].x*b1[p].x)%M; b1[rs].x=(b1[rs].x*b1[p].x)%M; b[ls].x=(b[ls].x*b1[p].x%M+b[p].x%M)%M; b[rs].x=(b[rs].x*b1[p].x%M+b[p].x%M)%M; b1[p].x=1; b[p].x=0; &#125; if(k==2) &#123; d[ls].y=(d[ls].y*b1[p].y%M+(mid-s+1)%M*b[p].y%M)%M; d[rs].y=(d[rs].y*b1[p].y%M+(t-mid)%M*b[p].y%M)%M; b1[ls].y=(b1[ls].y*b1[p].y)%M; b1[rs].y=(b1[rs].y*b1[p].y)%M; b[ls].y=(b[ls].y*b1[p].y%M+b[p].y%M)%M; b[rs].y=(b[rs].y*b1[p].y%M+b[p].y%M)%M; b1[p].y=1; b[p].y=0; &#125; if(k==3) &#123; d[ls].z=(d[ls].z*b1[p].z%M+(mid-s+1)%M*b[p].z%M)%M; d[rs].z=(d[rs].z*b1[p].z%M+(t-mid)%M*b[p].z%M)%M; b1[ls].z=(b1[ls].z*b1[p].z)%M; b1[rs].z=(b1[rs].z*b1[p].z)%M; b[ls].z=(b[ls].z*b1[p].z%M+b[p].z%M)%M; b[rs].z=(b[rs].z*b1[p].z%M+b[p].z%M)%M; b1[p].z=1; b[p].z=0; &#125; return;&#125;void pushup(int p,int k)&#123; if(k==1)d[p].x=(d[ls].x+d[rs].x)%M; if(k==2)d[p].y=(d[ls].y+d[rs].y)%M; if(k==3)d[p].z=(d[ls].z+d[rs].z)%M; return;&#125;void update1(int p,int l,int r,int s,int t,int k,int k1)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; add(p,k,s,t,k1); return; &#125; pushdown(p,s,t,k1); if(l&lt;=mid) update1(ls,l,r,s,mid,k,k1); if(r&gt;mid) update1(rs,l,r,mid+1,t,k,k1); pushup(p,k1);&#125;void update2(int p,int l,int r,int s,int t,int k,int k1)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; mul(p,k,s,t,k1); return; &#125; pushdown(p,s,t,k1); if(l&lt;=mid) update2(ls,l,r,s,mid,k,k1); if(r&gt;mid) update2(rs,l,r,mid+1,t,k,k1); pushup(p,k1);&#125;int query(int p,int l,int r,int s,int t,int k)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; if(k==1) return d[p].x; if(k==2) return d[p].y; if(k==3) return d[p].z; &#125; pushdown(p,s,t,k); int ans=0; if(l&lt;=mid) ans=(ans+query(ls,l,r,s,mid,k))%M; if(r&gt;mid) ans=(ans+query(rs,l,r,mid+1,t,k))%M; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; int sb,l,r; if(n&lt;=1000&amp;&amp;m&lt;=1000) &#123; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;sb&gt;&gt;l&gt;&gt;r; if(sb==1) &#123; int xx,yy,zz; cin&gt;&gt;xx&gt;&gt;yy&gt;&gt;zz; for(int j=l;j&lt;=r;j++) &#123; a[j].x=(a[j].x+xx%M)%M; a[j].y=(a[j].y+yy%M)%M; a[j].z=(a[j].z+zz%M)%M; &#125; &#125; if(sb==2) &#123; int kl; cin&gt;&gt;kl; for(int j=l;j&lt;=r;j++) &#123; a[j].x=kl%M*a[j].x%M; a[j].y=kl%M*a[j].y%M; a[j].z=kl%M*a[j].z%M; &#125; &#125; if(sb==3) &#123; for(int j=l;j&lt;=r;j++) &#123; int c=a[j].x; a[j].x=a[j].y; a[j].y=a[j].z; a[j].z=c; &#125; &#125; if(sb==4) &#123; int ans1=0,ans2=0,ans3=0; for(int j=l;j&lt;=r;j++) &#123; ans1=(ans1+a[j].x%M)%M; ans2=(ans2+a[j].y%M)%M; ans3=(ans3+a[j].z%M)%M; &#125; cout&lt;&lt;(((ans1*ans1)%M+(ans2*ans2)%M)%M+(ans3*ans3)%M)%M&lt;&lt;endl; &#125; &#125; &#125; else &#123; for(int i=0;i&lt;=4e5+39;i++) &#123; b1[i].x=1,b1[i].y=1,b[i].z=1; d[i].x=0,d[i].y=0,d[i].z=0; b[i].x=0,b[i].y=0,b[i].z=0; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;sb&gt;&gt;l&gt;&gt;r; if(sb==1) &#123; int zyc,ycz,czy; cin&gt;&gt;zyc&gt;&gt;ycz&gt;&gt;czy; update1(1,l,r,1,n,zyc,1); update1(1,l,r,1,n,ycz,2); update1(1,l,r,1,n,czy,3); &#125; if(sb==2) &#123; int k; cin&gt;&gt;k; update2(1,l,r,1,n,k,1); update2(1,l,r,1,n,k,2); update2(1,l,r,1,n,k,3); &#125; if(sb==3) &#123; continue; &#125; if(sb==4) &#123; int k11=query(1,l,r,1,n,1); int k22=query(1,l,r,1,n,2); int k33=query(1,l,r,1,n,3); cout&lt;&lt;(((k11*k11)%M+(k22*k22)%M)%M+(k33*k33)%M)%M&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"大模拟","slug":"大模拟","permalink":"http://zhang2514yuchi.github.io/tags/%E5%A4%A7%E6%A8%A1%E6%8B%9F/"}]},{"title":"NOIP2018 提高组 货币系统","slug":"P5020","date":"2022-03-03T10:26:59.000Z","updated":"2022-03-03T10:43:17.261Z","comments":true,"path":"2022/03/03/P5020/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/03/P5020/","excerpt":"一道巧妙的背包问题 可以想到用完全背包解决","text":"一道巧妙的背包问题 可以想到用完全背包解决 复杂度$O(n^2 \\times V)$ 1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt;a(n+1); int maxx=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=maxx;j++) &#123; b[j]=-inf; &#125; b[0]=0; int v=a[i]; for(int j=1;j&lt;=n;j++) &#123; if(j==i) continue; for(int k=a[j];k&lt;=v;k++) &#123; b[k]=max(b[k],b[k-a[j]]); &#125; &#125; if(b[a[i]]!=-inf) ans++; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; 这个复杂度一定会T，所以我们考虑优化 优化思路是排序 排序后的完全背包每个位置只会受小于等于它的数影响，而且事实上他也只能被小于等于自己的影响 保证正确性 $O（max(n \\log n,n \\times V））$ 12345678910111213141516171819202122232425262728293031323334int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt;a(n+1); int maxx=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); &#125; sort(a.begin(),a.end()); for(int i=1;i&lt;=maxx;i++) &#123; b[i]=-inf; &#125; b[0]=0; int ans=0; for(int i=1;i&lt;=n;i++) &#123; if(b[a[i]]!=-inf) ans++; for(int j=a[i];j&lt;=maxx;j++) &#123; b[j]=max(b[j],b[j-a[i]]); &#125; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"数论分块","slug":"数论分块","date":"2022-02-21T07:13:38.000Z","updated":"2022-02-21T07:15:17.466Z","comments":true,"path":"2022/02/21/数论分块/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","excerpt":"数论分块对于一类含有$\\lfloor \\frac{𝑛}{i} \\rfloor$的求和式 (𝑛 为常数)，由于$\\lfloor \\frac{𝑛}{i} \\rfloor$单调不增，故存在多个区间[𝑙,𝑟], 使得$\\lfloor \\frac{𝑛}{i} \\rfloor$&#x3D;$\\lfloor \\frac{𝑛}{j} \\rfloor$ (𝑖,𝑗∈[𝑙,𝑟]) 成立。 对于任意一个𝑖，最大的满足上式的 𝑗&#x3D;$\\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} }\\rfloor$","text":"数论分块对于一类含有$\\lfloor \\frac{𝑛}{i} \\rfloor$的求和式 (𝑛 为常数)，由于$\\lfloor \\frac{𝑛}{i} \\rfloor$单调不增，故存在多个区间[𝑙,𝑟], 使得$\\lfloor \\frac{𝑛}{i} \\rfloor$&#x3D;$\\lfloor \\frac{𝑛}{j} \\rfloor$ (𝑖,𝑗∈[𝑙,𝑟]) 成立。 对于任意一个𝑖，最大的满足上式的 𝑗&#x3D;$\\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} }\\rfloor$ 证明$\\lfloor \\frac{𝑛}{i} \\rfloor \\leqslant\\frac{𝑛}{i}$$\\Rightarrow \\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} }\\rfloor \\geqslant \\lfloor {\\frac{n}{ \\frac{𝑛}{i} } }\\rfloor &#x3D;\\lfloor i \\rfloor&#x3D;i$$\\Rightarrow i \\leqslant \\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} } \\rfloor$ 即$j&#x3D; \\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} }\\rfloor$ 例题经典题 P1403 [AHOI2005]约数研究题意：$f(x)$表示x的约数个数，求$\\sum_{i&#x3D;1}^nf(i)$思路：对于$i$,在$1～n$中，他的倍数有$\\lfloor \\frac{𝑛}{i} \\rfloor$个，因此$1～n$中共有个以$i$为约数的数。因此$\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^n\\lfloor \\frac{𝑛}{i} \\rfloor$ 现在考虑数论分块对于每一个l∈[1,n],存在区间[l,r],$r&#x3D;\\lfloor {\\frac{n}{\\lfloor \\frac{𝑛}{i} \\rfloor} }\\rfloor$使得$\\lfloor \\frac{𝑛}{i} \\rfloor$&#x3D;$\\lfloor \\frac{𝑛}{j} \\rfloor$区间贡献$(r-l+1)\\times \\lfloor \\frac{𝑛}{i} \\rfloor$.$O(2\\sqrt n)$ 1234567891011121314int n;signed main()&#123; n=rd; int ans=0; for(int i=1,j=1;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans+=(j-i+1)*(n/i); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; [CQOI2007]余数求和思路：$$\\sum_{i&#x3D;1}^{n} k\\ mod \\quad i&#x3D;\\sum_{i&#x3D;1}^{n} (k-\\lfloor \\frac{k}{i} \\rfloor \\times i)$$ 1234567891011121314int k,n;signed main()&#123; n=rd,k=rd; int ans=n*k; for(int i=1,j=1;i&lt;=n;i=j+1) &#123; if(k/i==0) break; j=min(n,k/(k/i)); ans-=(k/i)*(j+i)*(j-i+1)/2; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; P2424 约数和1234567891011121314151617int x,y;int f(int a)&#123; int ans=0; for(int i=1,j=1;i&lt;=a;i=j+1) &#123; j=a/(a/i); ans+=(a/i)*(i+j)*(j-i+1)/2; &#125; return ans;&#125;signed main()&#123; x=rd,y=rd; printf(&quot;%lld\\n&quot;,f(y)-f(x-1)); return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhang2514yuchi.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"分块","slug":"分块","permalink":"http://zhang2514yuchi.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"小z的袜子[国家集训队]","slug":"P1494","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:27:48.675Z","comments":true,"path":"2022/02/21/P1494/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P1494/","excerpt":"复健一波莫队，发现最经典的模版竟然没做过 正好复习下这种简单的","text":"复健一波莫队，发现最经典的模版竟然没做过 正好复习下这种简单的 P1494 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int n,m,ans=0,block;int col[Max],a[Max];struct node&#123; int l,r,id;&#125;q[Max];struct node1&#123; int x,y;&#125;res[Max];int gcd(int a,int b)&#123;return b == 0 ? a:gcd(b,a%b);&#125;bool cmp(node a,node b)&#123; return (a.l/block)^(b.l/block)?(a.l/block)&lt;(b.l/block):(a.l/block)&amp;1?a.r&lt;b.r:a.r&gt;b.r;&#125;void add(int x)&#123; ans+=2*col[a[x]]+1; col[a[x]]++;&#125;void del(int x)&#123; ans+=1-2*col[a[x]]; col[a[x]]--;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; block=sqrt(n); for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q+1,q+1+m,cmp); int l=1,r=0; for(int i=1;i&lt;=m;i++) &#123; int ql=q[i].l,qr=q[i].r; while(ql&lt;l) add(--l); while(ql&gt;l) del(l++); while(qr&lt;r) del(r--); while(qr&gt;r) add(++r); int len=qr-ql+1; if(ans-len==0) &#123;res[q[i].id].x=0,res[q[i].id].y=1;continue;&#125; int t=gcd(ans-len,(len-1)*len); res[q[i].id].x=(ans-len)/t; res[q[i].id].y=(len-1)*len/t; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;res[i].x&lt;&lt;&quot;/&quot;&lt;&lt;res[i].y&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"P4513 小白逛公园","slug":"P4513","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:27:53.305Z","comments":true,"path":"2022/02/21/P4513/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P4513/","excerpt":"题意：序列，单点修改，询问区间最大子段和最大子段和指的是找出一个可以是空的子区间，和最大","text":"题意：序列，单点修改，询问区间最大子段和最大子段和指的是找出一个可以是空的子区间，和最大 著名的新手杀手题。。。其实也不难对于每个区间，维护一个最大前缀，最大后缀，以及区间内部的答案每次合并的时候，即答案选取左子区间的max，右子区间的max，或者左子区间的最大后缀+右子区间的最大前缀 P4513 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define int long long#define mid ((s+t)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs (ls+1)using namespace std;const int Max=5e5+10;int n,m;int a[Max];struct node&#123; int res,sum,lm,rm;&#125;d[Max*4]; void pushup(int p)&#123; d[p].sum=d[ls].sum+d[rs].sum; d[p].res=max(d[ls].rm+d[rs].lm,max(d[rs].res,d[ls].res)); if(d[rs].lm&gt;d[ls].lm-d[ls].sum) d[p].lm=d[ls].sum+d[rs].lm; else d[p].lm=d[ls].lm; if(d[ls].rm&gt;d[rs].rm-d[rs].sum) d[p].rm=d[rs].sum+d[ls].rm; else d[p].rm=d[rs].rm;&#125;void build(int p,int s,int t)&#123; if(s==t) &#123; d[p].sum=a[s]; d[p].lm=a[s]; d[p].rm=a[s]; d[p].res=a[s]; return; &#125; build(ls,s,mid); build(rs,mid+1,t); pushup(p);&#125;void update(int p,int s,int t,int x,int c)&#123; if(s==t) &#123; d[p].sum=c; d[p].res=c; d[p].lm=c; d[p].rm=c; return; &#125; if(x&lt;=mid) update(ls,s,mid,x,c); else update(rs,mid+1,t,x,c); pushup(p);&#125;node query(int p,int l,int r,int s,int t)&#123; if(l&lt;=s&amp;&amp;r&gt;=t) &#123; return d[p]; &#125; if(r&lt;=mid) return query(ls,l,r,s,mid); else if(l&gt;mid) return query(rs,l,r,mid+1,t); else &#123; auto x=query(ls,l,r,s,mid),y=query(rs,l,r,mid+1,t); node ans; ans.sum=x.sum+y.sum; ans.res=max(x.rm+y.lm,max(x.res,y.res)); if(y.lm&gt;x.lm-x.sum) ans.lm=x.sum+y.lm; else ans.lm=x.lm; if(x.rm&gt;y.rm-y.sum) ans.rm=y.sum+x.rm; else ans.rm=y.rm; return ans; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(x==1) &#123; if(z&lt;y) swap(z,y); cout&lt;&lt;query(1,y,z,1,n).res&lt;&lt;&quot;\\n&quot;; &#125; else &#123; update(1,1,n,y,z); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-02-21T04:53:00.000Z","updated":"2022-02-21T08:49:38.695Z","comments":true,"path":"2022/02/21/数据结构/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"模版总结","text":"模版总结 树状数组脑子里画出这个图 区间查&#x2F;单点改123456789101112131415int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125; 差分实现区间改&#x2F;单点查1234567891011121314151617181920212223242526272829303132333435363738int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123;cin&gt;&gt;a[i];add(i,a[i]-a[i-1]);&#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x; if(x==1) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; add(l,k),add(r+1,-k); &#125; else &#123; cin&gt;&gt;k; cout&lt;&lt;sum(k)&lt;&lt;endl; &#125; &#125; return 0; &#125; 差分实现区间改&#x2F;区间查$$sum[i]&#x3D;\\sum_{j&#x3D;1}^i c[j] \\times(i-j+1)$$ $$sum[i]&#x3D;(i+1) \\times \\sum_{j&#x3D;1}^i c[j] -\\sum_{j&#x3D;1}^i c[j] \\times j$$ 123456789101112131415161718192021222324252627282930313233343536373839404142int n,m;int d1[Max],d2[Max],a[Max],b[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int *c,int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int *c,int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;inline int f(int x)&#123; return b[x]+(x+1)*sum(d1,x)-sum(d2,x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123; cin&gt;&gt;a[i]; b[i]=b[i-1]+a[i]; &#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x&gt;&gt;l&gt;&gt;r; if(x==1) &#123; cin&gt;&gt;k; add(d1,l,k),add(d1,r+1,-k),add(d2,l,k*l),add(d2,r+1,-k*(r+1)); &#125; else cout&lt;&lt;f(r)-f(l-1)&lt;&lt;endl; &#125; return 0; &#125; 最值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int m,n;int a[Max],c[Max],MAX[Max];char ch;inline int lowbit(int x)&#123;return x&amp;-x;&#125;void add(int p,int k)&#123; a[p]=k; while(p&lt;=n) &#123; c[p]=max(c[p],k); int t=lowbit(p); for(int i=1;i&lt;t;i*=2) c[p]=max(c[p],c[p-i]); p+=lowbit(p); &#125;&#125;int query(int l,int r)&#123; int ans=0; while(1) &#123; ans=max(ans,a[r]); if(r==l) break; for(r-=1;r-l&gt;=lowbit(r);r-=lowbit(r)) ans=max(ans,c[r]); &#125; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; pos(i,1,n) add(i,a[i]); int y,x; pos(i,1,m) &#123; ch=getchar(); while(ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=getchar(); scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); if(ch==&#x27;Q&#x27;) cout&lt;&lt;query(x,y)&lt;&lt;endl; else &#123; if(y&lt;=a[x]) continue; add(x,y); &#125; &#125; return 0;&#125; 线段树123#define mid (s+((t-s)&gt;&gt;1))#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1) 以下代码中$s,t$代表当前区间$l,r$代表询问区间 区间修改，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=(t-s+1)*c; b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 单点修改，区间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445int n,m;int a[Max],d[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; // pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int x,int s,int t,int p,int c)&#123; if(s==t) &#123; d[p]+=c; return; &#125; // pushdown(s,t,p); if(x&lt;=mid) update(x,s,mid,ls,c); if(x&gt;mid) update(x,mid+1,t,rs,c); pushup(p);&#125; 单点查询，区间修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int x,int s,int t,int p)&#123; if(s==t) &#123; return d[p]; &#125; pushdown(s,t,p); if(x&lt;=mid) return query(x,s,mid,ls); if(x&gt;mid) return query(x,mid+1,t,rs);&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=c*(t-s+1); b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 主席树 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int cnt,n,m;int a[Max],root[Max];struct Tree&#123; int l,r,val;&#125;tree[Max];int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123; tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123; tree[p].val=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query(int p,int s,int t,int x)&#123; if(s==t) return tree[p].val; if(x&lt;=mid) return query(tree[p].l,s,mid,x); else return query(tree[p].r,mid+1,t,x);&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; root[0]=build(0,1,n); return 0;&#125; 区间第k小123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; tree[cnt].val++; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123;// tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123;// tree[p].val+=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query1(int p,int q,int s,int t,int k)&#123; int x=tree[tree[p].l].val-tree[tree[q].l].val; if(s==t) return b[s]; if(x&gt;=k) return query1(tree[p].l,tree[q].l,s,mid,k); else return query1(tree[p].r,tree[q].r,mid+1,t,k-x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b+1,b+1+n); int nn=unique(b+1,b+1+n)-b-1; rt[0]=build(0,1,nn); for(int i=1;i&lt;=n;i++) &#123; int x=lower_bound(b+1,b+1+nn,a[i])-b; rt[i]=update(rt[i-1],1,nn,x,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; cout&lt;&lt;query1(rt[y],rt[x-1],1,nn,z)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"从博客园转来HEXO","slug":"介绍","date":"2022-02-20T14:46:56.000Z","updated":"2022-02-21T05:42:30.770Z","comments":true,"path":"2022/02/20/介绍/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/20/%E4%BB%8B%E7%BB%8D/","excerpt":"忍不了在博客园的那个了 在网上找了个教程自己搭一个hexo试试 后面陆续会手动把笔记都搬过来","text":"忍不了在博客园的那个了 在网上找了个教程自己搭一个hexo试试 后面陆续会手动把笔记都搬过来 博客园原址","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"},{"name":"高精度","slug":"高精度","permalink":"http://zhang2514yuchi.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"大模拟","slug":"大模拟","permalink":"http://zhang2514yuchi.github.io/tags/%E5%A4%A7%E6%A8%A1%E6%8B%9F/"},{"name":"数论","slug":"数论","permalink":"http://zhang2514yuchi.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"分块","slug":"分块","permalink":"http://zhang2514yuchi.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"莫队","slug":"莫队","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]}