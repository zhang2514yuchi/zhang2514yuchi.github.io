{"meta":{"title":"Juuichi","subtitle":"å¼ å®‡é©°çš„blog","description":"è®°å½•è®¡ç®—æœºç›¸å…³çŸ¥è¯†,ç®—æ³•åˆ·é¢˜ç¬”è®°ç­‰","author":"Juuichi","url":"http://zhang2514yuchi.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-20T16:46:40.679Z","updated":"2022-02-20T16:46:40.669Z","comments":true,"path":"about/index.html","permalink":"http://zhang2514yuchi.github.io/about/index.html","excerpt":"","text":"æˆ‘æ˜¯ Juuichi ç›®å‰å°±è¯»äº å“ˆå°”æ»¨å·¥ç¨‹å¤§å­¦ é€€å½¹ACMer"},{"title":"æ ‡ç­¾","date":"2022-02-21T04:33:30.000Z","updated":"2022-02-21T04:48:35.569Z","comments":true,"path":"tags/index.html","permalink":"http://zhang2514yuchi.github.io/tags/index.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"2022-02-21T04:34:53.000Z","updated":"2022-02-21T04:48:25.495Z","comments":true,"path":"categories/index.html","permalink":"http://zhang2514yuchi.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"P1040 [NOIP2003 æé«˜ç»„] åŠ åˆ†äºŒå‰æ ‘","slug":"P1040","date":"2022-03-14T11:20:07.000Z","updated":"2022-03-14T11:21:43.278Z","comments":true,"path":"2022/03/14/P1040/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/14/P1040/","excerpt":"ä¸€é“åŒºé—´dp é‡ç‚¹å…³æ³¨è·¯å¾„æ ‡è®°","text":"ä¸€é“åŒºé—´dp é‡ç‚¹å…³æ³¨è·¯å¾„æ ‡è®° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int Max=1e3+10;int n;int a[Max],dp[Max][Max],lt[Max],rt[Max],d[Max][Max],vis[Max];void dfs(int x)&#123; if(x==-1) return; cout&lt;&lt;x&lt;&lt;&quot; &quot;; dfs(lt[x]); dfs(rt[x]); return;&#125;void print(int l,int r) &#123; if(l&gt;r)return; cout&lt;&lt;d[l][r]&lt;&lt;&quot; &quot;; if (l == r)return; print(l, d[l][r] - 1); print(d[l][r]+1,r);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; dp[i][i]=a[i]; d[i][i]=i; &#125; for(int l=2;l&lt;=n;l++) &#123; for(int s=1;s&lt;=n-l+1;s++) &#123; int t=s+l-1; if(dp[s][t-1]+dp[t][t]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][t-1]+dp[t][t]; d[s][t]=t; &#125; if(dp[s][s]+dp[s+1][t]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][s]+dp[s+1][t]; d[s][t]=s; &#125; for(int k=s+1;k&lt;=t-1;k++) &#123; if(dp[s][k-1]*dp[k+1][t]+a[k]&gt;dp[s][t]) &#123; dp[s][t]=dp[s][k-1]*dp[k+1][t]+a[k]; d[s][t]=k; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; print(1,n); return 0;&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"é«˜ç²¾æ¨¡ç‰ˆå°ç»“","slug":"é«˜ç²¾","date":"2022-03-14T09:39:14.000Z","updated":"2022-03-14T09:42:26.741Z","comments":true,"path":"2022/03/14/é«˜ç²¾/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/14/%E9%AB%98%E7%B2%BE/","excerpt":"æ€»ç»“ä¸€ä¸‹å¸¸ç”¨é«˜ç²¾åº¦ $é«˜ç²¾+é«˜ç²¾$ $é«˜ç²¾\\timeså•ç²¾$ $\\max(é«˜ç²¾,é«˜ç²¾)$","text":"æ€»ç»“ä¸€ä¸‹å¸¸ç”¨é«˜ç²¾åº¦ $é«˜ç²¾+é«˜ç²¾$ $é«˜ç²¾\\timeså•ç²¾$ $\\max(é«˜ç²¾,é«˜ç²¾)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct HP&#123; int p[505],len; HP() &#123; memset(p,0,sizeof(p)); len=0; &#125; void print() &#123; cout&lt;&lt;p[len]; for(int i=len-1;i&gt;=1;i--) &#123; if(p[i]==0) &#123;cout&lt;&lt;&quot;0000&quot;;continue;&#125; for(int j=10;j*p[i]&lt;M;j*=10) cout&lt;&lt;&quot;0&quot;; cout&lt;&lt;p[i]; &#125; return; &#125;&#125;dp[Max][Max],b[110],res;HP operator + (const HP &amp;a,const HP &amp;b)&#123; int x=0; HP c; if(a.len&gt;b.len) c.len=a.len; else c.len=b.len; // c.len=max(a.len,b.len); for(int i=1;i&lt;=c.len;i++) &#123; c.p[i]=a.p[i]+b.p[i]+x; x=c.p[i]/M; c.p[i]%=M; &#125; if(x&gt;0) c.p[++c.len]=x; return c;&#125;HP operator * (const HP &amp;a,const int &amp;b)&#123; int x=0; HP c; c.len=a.len; for(int i=1;i&lt;=c.len;i++) &#123; c.p[i]=a.p[i]*b+x; x=c.p[i]/M; c.p[i]%=M; &#125; if(x&gt;0) c.p[++c.len]=x; return c;&#125;HP max(const HP &amp;a,const HP &amp;b)&#123; if(a.len&gt;b.len) &#123; return a; &#125; else if(a.len&lt;b.len) &#123; return b; &#125; else &#123; for(int i=a.len;i&gt;=1;i--) &#123; if(a.p[i]&gt;b.p[i]) return a; else if(a.p[i]&lt;b.p[i]) return b; else continue; &#125; return a; &#125;&#125;","categories":[],"tags":[{"name":"é«˜ç²¾åº¦","slug":"é«˜ç²¾åº¦","permalink":"http://zhang2514yuchi.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"çº¿ä»£å¤ä¹ -3-çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µä¸è¿ç®—","slug":"çº¿ä»£3","date":"2022-03-13T12:54:31.000Z","updated":"2022-03-14T03:42:22.441Z","comments":true,"path":"2022/03/13/çº¿ä»£3/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/13/%E7%BA%BF%E4%BB%A33/","excerpt":"çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µä¸è¿ç®—","text":"çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µä¸è¿ç®— 1.$AB&#x3D;BC,A\\ne0 \\Rightarrow A(B-C)&#x3D;0$ â€‹ $ \\nRightarrow B&#x3D;C$ 2.æ–¹é˜µä¹˜ç§¯çš„è¡Œåˆ—å¼ â€‹ è®¾$A,B$æ˜¯åŒé˜¶æ–¹é˜µï¼Œåˆ™$|AB|&#x3D;|A||B|.$ 3.é€†çŸ©é˜µçš„æ€§è´¨ â€‹ è®¾$A,B$æ˜¯åŒé˜¶å¯é€†çŸ©é˜µï¼Œåˆ™ â€‹ (1) $AB$ä¹Ÿå¯é€†ï¼Œä¸”$(AB)^{-1}&#x3D;B^{-1}A^{-1}$ â€‹ (2)$A^T$ä¹Ÿå¯é€†ï¼Œä¸”$(A^T)^{-1}&#x3D;(A^{-1})^T$ 4.åˆ†å—çŸ©é˜µçš„é€†ï¼Œè‹¥$A,B$å‡æ˜¯å¯é€†æ–¹é’ˆï¼Œåˆ™ï¼š 5.æ±‚æ–¹é˜µçš„å¹‚ (1)é€šè¿‡ç›´æ¥æˆ–è€…æ‹†æˆâ€“&gt;åˆ—$\\times$è¡Œ ï¼Œæ¥å‡‘å‰åä¸¤é¡¹ä¸ºå¸¸æ•°æˆ–å•ä½çŸ©é˜µ (2)ç®—å‡ºå‰å‡ æ¬¡å¹‚ï¼ˆ2æˆ–3ï¼‰å¯èƒ½ä¼šå‡ºç°å‘¨æœŸæˆ–è€…å¸¸æ•° (3)æ‹†æˆ$A+E$çš„å½¢å¼ï¼Œç„¶åæ ¹æ®äºŒé¡¹å¼å®šç†å±•å¼€ 6.*[é”™é¢˜æœ¬] $A,B$æ˜¯né˜¶æ–¹é˜µï¼Œæ»¡è¶³$AB&#x3D;A-B$ï¼Œè¯æ˜ï¼š$AB&#x3D;BA.$ 7.*[é”™é¢˜æœ¬] è¯æ˜å……åˆ†å¿…è¦æ¡ä»¶æ—¶ï¼Œåˆ†ä¸¤æ­¥ï¼šå……åˆ†æ€§å’Œå¿…è¦æ€§ 8.è‹¥$E+A$æ˜¯å¯é€†çŸ©é˜µï¼Œåˆ™æœ‰$(E-A)(E+A)^{-1}&#x3D;(E+A)^{-1}(E-A)$ å³$(E+A)^{-1}$å’Œ$(E-A)$å¯äº¤æ¢ 9.*[é”™é¢˜æœ¬] è®¾","categories":[],"tags":[{"name":"çº¿æ€§ä»£æ•°","slug":"çº¿æ€§ä»£æ•°","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P1156","slug":"P1156","date":"2022-03-10T03:32:52.000Z","updated":"2022-03-10T03:45:39.844Z","comments":true,"path":"2022/03/10/P1156/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/10/P1156/","excerpt":"ä¸€é“èƒŒåŒ…é—®é¢˜","text":"ä¸€é“èƒŒåŒ…é—®é¢˜ ä¸€å¼€å§‹æƒ³çš„ 1234if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h);if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h); if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); if(dp[i][j]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; çœ‹äº†ä¸‹åˆ«äººçš„ç±»ä¼¼æ€è·¯ 1234567891011if(j-x&lt;0) continue;dp[i][j-x]=max(dp[i][j-x],dp[i-1][j]+a[i].h);if(dp[i][j-x]&gt;=d)&#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0;&#125;if(j-x+a[i].f&lt;=10010)&#123; dp[i][j-x+a[i].f]=max(dp[i][j-x+a[i].f],dp[i-1][j]);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j-x&lt;0) continue; dp[i][j-x]=max(dp[i][j-x],dp[i-1][j]+a[i].h); if(dp[i][j-x]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; if(j-x+a[i].f&lt;=10010) &#123; dp[i][j-x+a[i].f]=max(dp[i][j-x+a[i].f],dp[i-1][j]); &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; åœ¨æˆ‘çš„æ€è·¯åŸºç¡€ä¸Šåªå¤šåŠ äº†ä¸€ä¸ªé™åˆ¶æ¡ä»¶ 1234if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h);if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010 &amp;&amp; j-a[i].f&gt;=0) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int Max=1e5+10;const int inf=1e9; const int M=1e8; int d,g;struct node&#123; int t,f,h;&#125;a[Max];int dp[201][10011];bool cmp(node a,node b)&#123;return a.t&lt;b.t;&#125;signed main()&#123; int n=0,ans=10; cin&gt;&gt;d&gt;&gt;g; for(int i=1;i&lt;=g;i++) &#123; cin&gt;&gt;a[i].t&gt;&gt;a[i].f&gt;&gt;a[i].h; n=max(n,a[i].t); &#125; sort(a+1,a+1+g,cmp); for(int i=0;i&lt;=200;i++) &#123; for(int j=0;j&lt;=10010;j++) dp[i][j]=-inf; &#125; dp[0][10]=0; for(int i=1;i&lt;=g;i++) &#123; int x=a[i].t-a[i-1].t; for(int j=0;j&lt;=10010;j++) &#123; if(j+x&lt;=10010) dp[i][j]=max(dp[i][j],dp[i-1][j+x]+a[i].h); if(j-a[i].f+x&gt;=0 &amp;&amp; j-a[i].f+x&lt;=10010 &amp;&amp; j-a[i].f&gt;=0) dp[i][j]=max(dp[i][j],dp[i-1][j-a[i].f+x]); if(dp[i][j]&gt;=d) &#123; cout&lt;&lt;a[i].t&lt;&lt;endl; return 0; &#125; &#125; &#125; for(int i=1;i&lt;=g;i++) &#123; if(ans&lt;a[i].t) break; ans+=a[i].f; &#125; cout&lt;&lt;ans; return 0;&#125; æ²¡æƒ³æ¸…æ¥šé™åˆ¶æ¡ä»¶ï¼Œå‘œå‘œ","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"CSP-202012 åˆ·é¢˜è®°å½•","slug":"csp202012","date":"2022-03-07T09:17:44.000Z","updated":"2022-03-10T04:12:39.514Z","comments":true,"path":"2022/03/07/csp202012/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/07/csp202012/","excerpt":"æ€»å¾—åˆ†ï¼š405","text":"æ€»å¾—åˆ†ï¼š405 ç¬¬ä¸‰é¢˜å¾—åˆ†ï¼š80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376#include&lt;bits/stdc++.h&gt;#define int long long using namespace std;const int Max=4e6+10;bool tr[Max];int siz[Max];int pre[Max];//tr==1ä»£è¡¨æ˜¯æ–‡ä»¶int cnt=0,fl=0;struct node&#123; int mulusiz,houdaisiz; int nowmulu,nowhoudai; set&lt;string&gt;st; map&lt;string,int&gt;mp;&#125;ml[Max];int read1(string x)&#123; int len=x.length(); for(int i=1;i&lt;len;i++) &#123; if(x[i]==&#x27;/&#x27;) &#123; return i; &#125; &#125; return len-1;&#125;bool check(string x,int y,int z)&#123; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; //yæ˜¯å½“å‰ç›®å½•ï¼Œs1æ˜¯å½“å‰è¦è®¿é—®çš„ä¸œè¥¿ if(ml[y].st.find(s1)!=ml[y].st.end())//æ‰¾åˆ° &#123; int now=ml[y].mp[s1]; if(s2==&quot;&quot;) &#123; if(tr[now]) &#123; int z1=z-siz[now]; if(ml[y].mulusiz-ml[y].nowmulu&gt;=z1 &amp;&amp; ml[y].houdaisiz-ml[y].nowhoudai&gt;=z1) &#123; ++cnt; ml[y].mp[s1]=cnt; tr[cnt]=1; siz[cnt]=z; ml[y].nowmulu+=z1; int k=y; while(k!=-1) &#123; ml[k].nowhoudai+=z1; k=pre[k]; &#125; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; if(tr[now]) &#123; return 0; &#125; else &#123; if( ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; pre[now]=y; return check(s2,now,z); &#125; else &#123; return 0; &#125; &#125; &#125; &#125; else &#123; if(s2==&quot;&quot;) &#123; if(ml[y].mulusiz-ml[y].nowmulu&gt;=z &amp;&amp; ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; ++cnt; ml[y].st.insert(s1); ml[y].mp[s1]=cnt; tr[cnt]=1; siz[cnt]=z; ml[y].nowmulu+=z; int k=y; while(k!=-1) &#123; ml[k].nowhoudai+=z; k=pre[k]; &#125; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; if( ml[y].houdaisiz-ml[y].nowhoudai&gt;=z) &#123; ++cnt; ml[y].st.insert(s1); ml[y].mp[s1]=cnt; tr[cnt]=0; ml[cnt].houdaisiz=2e18; ml[cnt].mulusiz=2e18; ml[cnt].nowhoudai=0; ml[cnt].nowmulu=0; pre[cnt]=y; return check(s2,cnt,z); &#125; else &#123; return 0; &#125; &#125; &#125; &#125;void shanchu(string x,int y)&#123; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; if(ml[y].st.find(s1)!=ml[y].st.end())//æ‰¾åˆ°äº† &#123; if(s2==&quot;&quot;)//å¶å­ &#123; if(tr[ml[y].mp[s1]])//æ–‡ä»¶ &#123; ml[y].st.erase(s1); int k=siz[ml[y].mp[s1]]; ml[y].mp[s1]=0; int i=y; ml[y].nowmulu-=k; while(i!=-1) &#123; ml[i].nowhoudai-=k; i=pre[i]; &#125; return; &#125; else &#123; ml[y].st.erase(s1); int k=ml[ml[y].mp[s1]].nowhoudai; ml[y].mp[s1]=0; int i=y; while(i!=-1) &#123; ml[i].nowhoudai-=k; i=pre[i]; &#125; return; &#125; &#125; else &#123; if(tr[ml[y].mp[s1]]) &#123; return; &#125; else &#123; pre[ml[y].mp[s1]]=y; shanchu(s2,ml[y].mp[s1]); return; &#125; &#125; &#125; else &#123; return; &#125;&#125;bool shezhi(string x,int y,int ld,int lr)&#123; if(x==&quot;/&quot;) &#123; if(ml[0].nowmulu&gt;ld||ml[0].nowhoudai&gt;lr) &#123; return 0; &#125; else &#123; ml[0].mulusiz=ld; ml[0].houdaisiz=lr; return 1; &#125; &#125; int len=x.length(); int p=read1(x); string s1,s2; if(p==len-1) &#123; for(int i=1;i&lt;p+1;i++) &#123; s1=s1+x[i]; &#125; s2=&quot;&quot;; &#125; else &#123; for(int i=1;i&lt;p;i++) &#123; s1=s1+x[i]; &#125; for(int i=p;i&lt;len;i++) &#123; s2=s2+x[i]; &#125; &#125; if(ml[y].st.find(s1)!=ml[y].st.end())//æ‰¾åˆ°äº† &#123; if(s2==&quot;&quot;)//å¶å­ &#123; if(tr[ml[y].mp[s1]])//æ–‡ä»¶ &#123; return 0; &#125; else &#123; if(ml[ml[y].mp[s1]].nowmulu&gt;ld||ml[ml[y].mp[s1]].nowhoudai&gt;lr) &#123; return 0; &#125; else &#123; ml[ml[y].mp[s1]].mulusiz=ld; ml[ml[y].mp[s1]].houdaisiz=lr; return 1; &#125; &#125; &#125; else &#123; if(tr[ml[y].mp[s1]]) &#123; return 0; &#125; else &#123; return shezhi(s2,ml[y].mp[s1],ld,lr); &#125; &#125; &#125; else &#123; return 0; &#125;&#125;signed main()&#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n; cin&gt;&gt;n; ml[0].mulusiz=2e18; ml[0].houdaisiz=2e18; ml[0].nowhoudai=0; ml[0].nowmulu=0; pre[0]=-1; for(int i=1;i&lt;=n;i++) &#123; char c; string s1; c=getchar(); while(c&lt;&#x27;A&#x27;||c&gt;&#x27;Z&#x27;) c=getchar(); if(c==&#x27;C&#x27;) &#123; int g; cin&gt;&gt;s1&gt;&gt;g; if(check(s1,0,g)) &#123; cout&lt;&lt;&quot;Y\\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;N\\n&quot;; &#125; &#125; else if(c==&#x27;R&#x27;) &#123; cin&gt;&gt;s1; fl=0; shanchu(s1,0); cout&lt;&lt;&quot;Y\\n&quot;; &#125; else if(c==&#x27;Q&#x27;) &#123; int ld,lr; cin&gt;&gt;s1&gt;&gt;ld&gt;&gt;lr; if(ld==0) ld=2e18; if(lr==0) lr=2e18; if(shezhi(s1,0,ld,lr)) &#123; cout&lt;&lt;&quot;Y\\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;N\\n&quot;; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125; ç¬¬å››é¢˜å¾—åˆ†ï¼š65 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;int n,m,k;int b[110][20];int cnt=0,h[1000],ans=0,mx=0;struct Edge&#123; int to,nxt,l;&#125;e[2000];void add(int u,int v,int w)&#123; e[++cnt].to=v; e[cnt].nxt=h[u]; e[cnt].l=w; h[u]=cnt;&#125;bool dfs(int u,int fa,int k,int dep)&#123; int tr=b[u][k]; for(int i=h[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==fa) continue; if(dfs(v,u,k,dep+e[i].l)) &#123; tr=1; ans+=e[i].l*2; &#125; &#125; if(tr) &#123; mx=max(mx,dep); return 1; &#125; else return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=k;j++) cin&gt;&gt;b[i][j]; &#125; for(int i=1;i&lt;n;i++) &#123; int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; add(u,v,w); add(v,u,w); &#125; int tmp=0; for(int i=1;i&lt;=k;i++) &#123; int res=inf; for(int j=1;j&lt;=n;j++) &#123; ans=0,mx=0; dfs(j,0,i,0); res=min(res,ans-mx); &#125; tmp=max(tmp,res); &#125; cout&lt;&lt;tmp; return 0;&#125; ç¬¬äº”é¢˜å¾—åˆ†ï¼š60 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include&lt;bits/stdc++.h&gt;#define int long long #define mid ((s+t)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1)using namespace std;const int Max=1e5+10;const int M=1e9+7;int n,m;struct node&#123; int x,y,z;&#125;d[Max*4],b[Max*4],a[Max],b1[Max*4];void add(int p,int k,int s,int t,int k1)&#123; if(k1==1) &#123; d[p].x=(d[p].x+k%M*(t-s+1)%M)%M; b[p].x=(b[p].x+k%M)%M; &#125; if(k1==2) &#123; d[p].y=(d[p].y+k%M*(t-s+1)%M)%M; b[p].y=(b[p].y+k%M)%M; &#125; if(k1==3) &#123; d[p].z=(d[p].z+k%M*(t-s+1)%M)%M; b[p].z=(b[p].z+k%M)%M; &#125; return;&#125;void mul(int p,int k,int s,int t,int k1)&#123; if(k1==1) &#123; d[p].x=k*d[p].x%M; b[p].x=k*b[p].x%M; b1[p].x=k*b1[p].x%M; &#125; if(k1==2) &#123; d[p].y=k*d[p].y%M; b[p].y=k*b[p].y%M; b1[p].y=k*b1[p].y%M; &#125; if(k1==3) &#123; d[p].z=k*d[p].z%M; b[p].z=k*b[p].z%M; b1[p].z=k*b1[p].z%M; &#125; return;&#125;void pushdown(int p,int s,int t,int k)&#123; if(k==1) &#123; d[ls].x=(d[ls].x*b1[p].x%M+(mid-s+1)%M*b[p].x%M)%M; d[rs].x=(d[rs].x*b1[p].x%M+(t-mid)%M*b[p].x%M)%M; b1[ls].x=(b1[ls].x*b1[p].x)%M; b1[rs].x=(b1[rs].x*b1[p].x)%M; b[ls].x=(b[ls].x*b1[p].x%M+b[p].x%M)%M; b[rs].x=(b[rs].x*b1[p].x%M+b[p].x%M)%M; b1[p].x=1; b[p].x=0; &#125; if(k==2) &#123; d[ls].y=(d[ls].y*b1[p].y%M+(mid-s+1)%M*b[p].y%M)%M; d[rs].y=(d[rs].y*b1[p].y%M+(t-mid)%M*b[p].y%M)%M; b1[ls].y=(b1[ls].y*b1[p].y)%M; b1[rs].y=(b1[rs].y*b1[p].y)%M; b[ls].y=(b[ls].y*b1[p].y%M+b[p].y%M)%M; b[rs].y=(b[rs].y*b1[p].y%M+b[p].y%M)%M; b1[p].y=1; b[p].y=0; &#125; if(k==3) &#123; d[ls].z=(d[ls].z*b1[p].z%M+(mid-s+1)%M*b[p].z%M)%M; d[rs].z=(d[rs].z*b1[p].z%M+(t-mid)%M*b[p].z%M)%M; b1[ls].z=(b1[ls].z*b1[p].z)%M; b1[rs].z=(b1[rs].z*b1[p].z)%M; b[ls].z=(b[ls].z*b1[p].z%M+b[p].z%M)%M; b[rs].z=(b[rs].z*b1[p].z%M+b[p].z%M)%M; b1[p].z=1; b[p].z=0; &#125; return;&#125;void pushup(int p,int k)&#123; if(k==1)d[p].x=(d[ls].x+d[rs].x)%M; if(k==2)d[p].y=(d[ls].y+d[rs].y)%M; if(k==3)d[p].z=(d[ls].z+d[rs].z)%M; return;&#125;void update1(int p,int l,int r,int s,int t,int k,int k1)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; add(p,k,s,t,k1); return; &#125; pushdown(p,s,t,k1); if(l&lt;=mid) update1(ls,l,r,s,mid,k,k1); if(r&gt;mid) update1(rs,l,r,mid+1,t,k,k1); pushup(p,k1);&#125;void update2(int p,int l,int r,int s,int t,int k,int k1)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; mul(p,k,s,t,k1); return; &#125; pushdown(p,s,t,k1); if(l&lt;=mid) update2(ls,l,r,s,mid,k,k1); if(r&gt;mid) update2(rs,l,r,mid+1,t,k,k1); pushup(p,k1);&#125;int query(int p,int l,int r,int s,int t,int k)&#123; if(l&lt;=s &amp;&amp; r&gt;=t) &#123; if(k==1) return d[p].x; if(k==2) return d[p].y; if(k==3) return d[p].z; &#125; pushdown(p,s,t,k); int ans=0; if(l&lt;=mid) ans=(ans+query(ls,l,r,s,mid,k))%M; if(r&gt;mid) ans=(ans+query(rs,l,r,mid+1,t,k))%M; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; int sb,l,r; if(n&lt;=1000&amp;&amp;m&lt;=1000) &#123; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;sb&gt;&gt;l&gt;&gt;r; if(sb==1) &#123; int xx,yy,zz; cin&gt;&gt;xx&gt;&gt;yy&gt;&gt;zz; for(int j=l;j&lt;=r;j++) &#123; a[j].x=(a[j].x+xx%M)%M; a[j].y=(a[j].y+yy%M)%M; a[j].z=(a[j].z+zz%M)%M; &#125; &#125; if(sb==2) &#123; int kl; cin&gt;&gt;kl; for(int j=l;j&lt;=r;j++) &#123; a[j].x=kl%M*a[j].x%M; a[j].y=kl%M*a[j].y%M; a[j].z=kl%M*a[j].z%M; &#125; &#125; if(sb==3) &#123; for(int j=l;j&lt;=r;j++) &#123; int c=a[j].x; a[j].x=a[j].y; a[j].y=a[j].z; a[j].z=c; &#125; &#125; if(sb==4) &#123; int ans1=0,ans2=0,ans3=0; for(int j=l;j&lt;=r;j++) &#123; ans1=(ans1+a[j].x%M)%M; ans2=(ans2+a[j].y%M)%M; ans3=(ans3+a[j].z%M)%M; &#125; cout&lt;&lt;(((ans1*ans1)%M+(ans2*ans2)%M)%M+(ans3*ans3)%M)%M&lt;&lt;endl; &#125; &#125; &#125; else &#123; for(int i=0;i&lt;=4e5+39;i++) &#123; b1[i].x=1,b1[i].y=1,b[i].z=1; d[i].x=0,d[i].y=0,d[i].z=0; b[i].x=0,b[i].y=0,b[i].z=0; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;sb&gt;&gt;l&gt;&gt;r; if(sb==1) &#123; int zyc,ycz,czy; cin&gt;&gt;zyc&gt;&gt;ycz&gt;&gt;czy; update1(1,l,r,1,n,zyc,1); update1(1,l,r,1,n,ycz,2); update1(1,l,r,1,n,czy,3); &#125; if(sb==2) &#123; int k; cin&gt;&gt;k; update2(1,l,r,1,n,k,1); update2(1,l,r,1,n,k,2); update2(1,l,r,1,n,k,3); &#125; if(sb==3) &#123; continue; &#125; if(sb==4) &#123; int k11=query(1,l,r,1,n,1); int k22=query(1,l,r,1,n,2); int k33=query(1,l,r,1,n,3); cout&lt;&lt;(((k11*k11)%M+(k22*k22)%M)%M+(k33*k33)%M)%M&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"å¤§æ¨¡æ‹Ÿ","slug":"å¤§æ¨¡æ‹Ÿ","permalink":"http://zhang2514yuchi.github.io/tags/%E5%A4%A7%E6%A8%A1%E6%8B%9F/"}]},{"title":"NOIP2018 æé«˜ç»„ è´§å¸ç³»ç»Ÿ","slug":"P5020","date":"2022-03-03T10:26:59.000Z","updated":"2022-03-03T10:43:17.261Z","comments":true,"path":"2022/03/03/P5020/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/03/03/P5020/","excerpt":"ä¸€é“å·§å¦™çš„èƒŒåŒ…é—®é¢˜ å¯ä»¥æƒ³åˆ°ç”¨å®Œå…¨èƒŒåŒ…è§£å†³","text":"ä¸€é“å·§å¦™çš„èƒŒåŒ…é—®é¢˜ å¯ä»¥æƒ³åˆ°ç”¨å®Œå…¨èƒŒåŒ…è§£å†³ å¤æ‚åº¦$O(n^2 \\times V)$ 1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt;a(n+1); int maxx=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=maxx;j++) &#123; b[j]=-inf; &#125; b[0]=0; int v=a[i]; for(int j=1;j&lt;=n;j++) &#123; if(j==i) continue; for(int k=a[j];k&lt;=v;k++) &#123; b[k]=max(b[k],b[k-a[j]]); &#125; &#125; if(b[a[i]]!=-inf) ans++; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; è¿™ä¸ªå¤æ‚åº¦ä¸€å®šä¼šTï¼Œæ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¼˜åŒ– ä¼˜åŒ–æ€è·¯æ˜¯æ’åº æ’åºåçš„å®Œå…¨èƒŒåŒ…æ¯ä¸ªä½ç½®åªä¼šå—å°äºç­‰äºå®ƒçš„æ•°å½±å“ï¼Œè€Œä¸”äº‹å®ä¸Šä»–ä¹Ÿåªèƒ½è¢«å°äºç­‰äºè‡ªå·±çš„å½±å“ ä¿è¯æ­£ç¡®æ€§ $Oï¼ˆmax(n \\log n,n \\times Vï¼‰ï¼‰$ 12345678910111213141516171819202122232425262728293031323334int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; vector&lt;int&gt;a(n+1); int maxx=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); &#125; sort(a.begin(),a.end()); for(int i=1;i&lt;=maxx;i++) &#123; b[i]=-inf; &#125; b[0]=0; int ans=0; for(int i=1;i&lt;=n;i++) &#123; if(b[a[i]]!=-inf) ans++; for(int j=a[i];j&lt;=maxx;j++) &#123; b[j]=max(b[j],b[j-a[i]]); &#125; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"}]},{"title":"æ•°è®ºåˆ†å—","slug":"æ•°è®ºåˆ†å—","date":"2022-02-21T07:13:38.000Z","updated":"2022-02-21T07:15:17.466Z","comments":true,"path":"2022/02/21/æ•°è®ºåˆ†å—/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","excerpt":"æ•°è®ºåˆ†å—å¯¹äºä¸€ç±»å«æœ‰$\\lfloor \\frac{ğ‘›}{i} \\rfloor$çš„æ±‚å’Œå¼ (ğ‘› ä¸ºå¸¸æ•°)ï¼Œç”±äº$\\lfloor \\frac{ğ‘›}{i} \\rfloor$å•è°ƒä¸å¢ï¼Œæ•…å­˜åœ¨å¤šä¸ªåŒºé—´[ğ‘™,ğ‘Ÿ], ä½¿å¾—$\\lfloor \\frac{ğ‘›}{i} \\rfloor$&#x3D;$\\lfloor \\frac{ğ‘›}{j} \\rfloor$ (ğ‘–,ğ‘—âˆˆ[ğ‘™,ğ‘Ÿ]) æˆç«‹ã€‚ å¯¹äºä»»æ„ä¸€ä¸ªğ‘–ï¼Œæœ€å¤§çš„æ»¡è¶³ä¸Šå¼çš„ ğ‘—&#x3D;$\\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} }\\rfloor$","text":"æ•°è®ºåˆ†å—å¯¹äºä¸€ç±»å«æœ‰$\\lfloor \\frac{ğ‘›}{i} \\rfloor$çš„æ±‚å’Œå¼ (ğ‘› ä¸ºå¸¸æ•°)ï¼Œç”±äº$\\lfloor \\frac{ğ‘›}{i} \\rfloor$å•è°ƒä¸å¢ï¼Œæ•…å­˜åœ¨å¤šä¸ªåŒºé—´[ğ‘™,ğ‘Ÿ], ä½¿å¾—$\\lfloor \\frac{ğ‘›}{i} \\rfloor$&#x3D;$\\lfloor \\frac{ğ‘›}{j} \\rfloor$ (ğ‘–,ğ‘—âˆˆ[ğ‘™,ğ‘Ÿ]) æˆç«‹ã€‚ å¯¹äºä»»æ„ä¸€ä¸ªğ‘–ï¼Œæœ€å¤§çš„æ»¡è¶³ä¸Šå¼çš„ ğ‘—&#x3D;$\\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} }\\rfloor$ è¯æ˜$\\lfloor \\frac{ğ‘›}{i} \\rfloor \\leqslant\\frac{ğ‘›}{i}$$\\Rightarrow \\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} }\\rfloor \\geqslant \\lfloor {\\frac{n}{ \\frac{ğ‘›}{i} } }\\rfloor &#x3D;\\lfloor i \\rfloor&#x3D;i$$\\Rightarrow i \\leqslant \\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} } \\rfloor$ å³$j&#x3D; \\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} }\\rfloor$ ä¾‹é¢˜ç»å…¸é¢˜ P1403 [AHOI2005]çº¦æ•°ç ”ç©¶é¢˜æ„ï¼š$f(x)$è¡¨ç¤ºxçš„çº¦æ•°ä¸ªæ•°ï¼Œæ±‚$\\sum_{i&#x3D;1}^nf(i)$æ€è·¯ï¼šå¯¹äº$i$,åœ¨$1ï½n$ä¸­ï¼Œä»–çš„å€æ•°æœ‰$\\lfloor \\frac{ğ‘›}{i} \\rfloor$ä¸ªï¼Œå› æ­¤$1ï½n$ä¸­å…±æœ‰ä¸ªä»¥$i$ä¸ºçº¦æ•°çš„æ•°ã€‚å› æ­¤$\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^n\\lfloor \\frac{ğ‘›}{i} \\rfloor$ ç°åœ¨è€ƒè™‘æ•°è®ºåˆ†å—å¯¹äºæ¯ä¸€ä¸ªlâˆˆ[1,n],å­˜åœ¨åŒºé—´[l,r],$r&#x3D;\\lfloor {\\frac{n}{\\lfloor \\frac{ğ‘›}{i} \\rfloor} }\\rfloor$ä½¿å¾—$\\lfloor \\frac{ğ‘›}{i} \\rfloor$&#x3D;$\\lfloor \\frac{ğ‘›}{j} \\rfloor$åŒºé—´è´¡çŒ®$(r-l+1)\\times \\lfloor \\frac{ğ‘›}{i} \\rfloor$.$O(2\\sqrt n)$ 1234567891011121314int n;signed main()&#123; n=rd; int ans=0; for(int i=1,j=1;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans+=(j-i+1)*(n/i); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; [CQOI2007]ä½™æ•°æ±‚å’Œæ€è·¯ï¼š$$\\sum_{i&#x3D;1}^{n} k\\ mod \\quad i&#x3D;\\sum_{i&#x3D;1}^{n} (k-\\lfloor \\frac{k}{i} \\rfloor \\times i)$$ 1234567891011121314int k,n;signed main()&#123; n=rd,k=rd; int ans=n*k; for(int i=1,j=1;i&lt;=n;i=j+1) &#123; if(k/i==0) break; j=min(n,k/(k/i)); ans-=(k/i)*(j+i)*(j-i+1)/2; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; P2424 çº¦æ•°å’Œ1234567891011121314151617int x,y;int f(int a)&#123; int ans=0; for(int i=1,j=1;i&lt;=a;i=j+1) &#123; j=a/(a/i); ans+=(a/i)*(i+j)*(j-i+1)/2; &#125; return ans;&#125;signed main()&#123; x=rd,y=rd; printf(&quot;%lld\\n&quot;,f(y)-f(x-1)); return 0;&#125;","categories":[],"tags":[{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"http://zhang2514yuchi.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"åˆ†å—","slug":"åˆ†å—","permalink":"http://zhang2514yuchi.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"å°zçš„è¢œå­[å›½å®¶é›†è®­é˜Ÿ]","slug":"P1494","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:27:48.675Z","comments":true,"path":"2022/02/21/P1494/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P1494/","excerpt":"å¤å¥ä¸€æ³¢è«é˜Ÿï¼Œå‘ç°æœ€ç»å…¸çš„æ¨¡ç‰ˆç«Ÿç„¶æ²¡åšè¿‡ æ­£å¥½å¤ä¹ ä¸‹è¿™ç§ç®€å•çš„","text":"å¤å¥ä¸€æ³¢è«é˜Ÿï¼Œå‘ç°æœ€ç»å…¸çš„æ¨¡ç‰ˆç«Ÿç„¶æ²¡åšè¿‡ æ­£å¥½å¤ä¹ ä¸‹è¿™ç§ç®€å•çš„ P1494 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int n,m,ans=0,block;int col[Max],a[Max];struct node&#123; int l,r,id;&#125;q[Max];struct node1&#123; int x,y;&#125;res[Max];int gcd(int a,int b)&#123;return b == 0 ? a:gcd(b,a%b);&#125;bool cmp(node a,node b)&#123; return (a.l/block)^(b.l/block)?(a.l/block)&lt;(b.l/block):(a.l/block)&amp;1?a.r&lt;b.r:a.r&gt;b.r;&#125;void add(int x)&#123; ans+=2*col[a[x]]+1; col[a[x]]++;&#125;void del(int x)&#123; ans+=1-2*col[a[x]]; col[a[x]]--;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; block=sqrt(n); for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q+1,q+1+m,cmp); int l=1,r=0; for(int i=1;i&lt;=m;i++) &#123; int ql=q[i].l,qr=q[i].r; while(ql&lt;l) add(--l); while(ql&gt;l) del(l++); while(qr&lt;r) del(r--); while(qr&gt;r) add(++r); int len=qr-ql+1; if(ans-len==0) &#123;res[q[i].id].x=0,res[q[i].id].y=1;continue;&#125; int t=gcd(ans-len,(len-1)*len); res[q[i].id].x=(ans-len)/t; res[q[i].id].y=(len-1)*len/t; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;res[i].x&lt;&lt;&quot;/&quot;&lt;&lt;res[i].y&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"è«é˜Ÿ","slug":"è«é˜Ÿ","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"P4513 å°ç™½é€›å…¬å›­","slug":"P4513","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:27:53.305Z","comments":true,"path":"2022/02/21/P4513/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P4513/","excerpt":"é¢˜æ„ï¼šåºåˆ—ï¼Œå•ç‚¹ä¿®æ”¹ï¼Œè¯¢é—®åŒºé—´æœ€å¤§å­æ®µå’Œæœ€å¤§å­æ®µå’ŒæŒ‡çš„æ˜¯æ‰¾å‡ºä¸€ä¸ªå¯ä»¥æ˜¯ç©ºçš„å­åŒºé—´ï¼Œå’Œæœ€å¤§","text":"é¢˜æ„ï¼šåºåˆ—ï¼Œå•ç‚¹ä¿®æ”¹ï¼Œè¯¢é—®åŒºé—´æœ€å¤§å­æ®µå’Œæœ€å¤§å­æ®µå’ŒæŒ‡çš„æ˜¯æ‰¾å‡ºä¸€ä¸ªå¯ä»¥æ˜¯ç©ºçš„å­åŒºé—´ï¼Œå’Œæœ€å¤§ è‘—åçš„æ–°æ‰‹æ€æ‰‹é¢˜ã€‚ã€‚ã€‚å…¶å®ä¹Ÿä¸éš¾å¯¹äºæ¯ä¸ªåŒºé—´ï¼Œç»´æŠ¤ä¸€ä¸ªæœ€å¤§å‰ç¼€ï¼Œæœ€å¤§åç¼€ï¼Œä»¥åŠåŒºé—´å†…éƒ¨çš„ç­”æ¡ˆæ¯æ¬¡åˆå¹¶çš„æ—¶å€™ï¼Œå³ç­”æ¡ˆé€‰å–å·¦å­åŒºé—´çš„maxï¼Œå³å­åŒºé—´çš„maxï¼Œæˆ–è€…å·¦å­åŒºé—´çš„æœ€å¤§åç¼€+å³å­åŒºé—´çš„æœ€å¤§å‰ç¼€ P4513 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define int long long#define mid ((s+t)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs (ls+1)using namespace std;const int Max=5e5+10;int n,m;int a[Max];struct node&#123; int res,sum,lm,rm;&#125;d[Max*4]; void pushup(int p)&#123; d[p].sum=d[ls].sum+d[rs].sum; d[p].res=max(d[ls].rm+d[rs].lm,max(d[rs].res,d[ls].res)); if(d[rs].lm&gt;d[ls].lm-d[ls].sum) d[p].lm=d[ls].sum+d[rs].lm; else d[p].lm=d[ls].lm; if(d[ls].rm&gt;d[rs].rm-d[rs].sum) d[p].rm=d[rs].sum+d[ls].rm; else d[p].rm=d[rs].rm;&#125;void build(int p,int s,int t)&#123; if(s==t) &#123; d[p].sum=a[s]; d[p].lm=a[s]; d[p].rm=a[s]; d[p].res=a[s]; return; &#125; build(ls,s,mid); build(rs,mid+1,t); pushup(p);&#125;void update(int p,int s,int t,int x,int c)&#123; if(s==t) &#123; d[p].sum=c; d[p].res=c; d[p].lm=c; d[p].rm=c; return; &#125; if(x&lt;=mid) update(ls,s,mid,x,c); else update(rs,mid+1,t,x,c); pushup(p);&#125;node query(int p,int l,int r,int s,int t)&#123; if(l&lt;=s&amp;&amp;r&gt;=t) &#123; return d[p]; &#125; if(r&lt;=mid) return query(ls,l,r,s,mid); else if(l&gt;mid) return query(rs,l,r,mid+1,t); else &#123; auto x=query(ls,l,r,s,mid),y=query(rs,l,r,mid+1,t); node ans; ans.sum=x.sum+y.sum; ans.res=max(x.rm+y.lm,max(x.res,y.res)); if(y.lm&gt;x.lm-x.sum) ans.lm=x.sum+y.lm; else ans.lm=x.lm; if(x.rm&gt;y.rm-y.sum) ans.rm=y.sum+x.rm; else ans.rm=y.rm; return ans; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(x==1) &#123; if(z&lt;y) swap(z,y); cout&lt;&lt;query(1,y,z,1,n).res&lt;&lt;&quot;\\n&quot;; &#125; else &#123; update(1,1,n,y,z); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","date":"2022-02-21T04:53:00.000Z","updated":"2022-02-21T08:49:38.695Z","comments":true,"path":"2022/02/21/æ•°æ®ç»“æ„/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"æ¨¡ç‰ˆæ€»ç»“","text":"æ¨¡ç‰ˆæ€»ç»“ æ ‘çŠ¶æ•°ç»„è„‘å­é‡Œç”»å‡ºè¿™ä¸ªå›¾ åŒºé—´æŸ¥&#x2F;å•ç‚¹æ”¹123456789101112131415int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125; å·®åˆ†å®ç°åŒºé—´æ”¹&#x2F;å•ç‚¹æŸ¥1234567891011121314151617181920212223242526272829303132333435363738int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123;cin&gt;&gt;a[i];add(i,a[i]-a[i-1]);&#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x; if(x==1) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; add(l,k),add(r+1,-k); &#125; else &#123; cin&gt;&gt;k; cout&lt;&lt;sum(k)&lt;&lt;endl; &#125; &#125; return 0; &#125; å·®åˆ†å®ç°åŒºé—´æ”¹&#x2F;åŒºé—´æŸ¥$$sum[i]&#x3D;\\sum_{j&#x3D;1}^i c[j] \\times(i-j+1)$$ $$sum[i]&#x3D;(i+1) \\times \\sum_{j&#x3D;1}^i c[j] -\\sum_{j&#x3D;1}^i c[j] \\times j$$ 123456789101112131415161718192021222324252627282930313233343536373839404142int n,m;int d1[Max],d2[Max],a[Max],b[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int *c,int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int *c,int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;inline int f(int x)&#123; return b[x]+(x+1)*sum(d1,x)-sum(d2,x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123; cin&gt;&gt;a[i]; b[i]=b[i-1]+a[i]; &#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x&gt;&gt;l&gt;&gt;r; if(x==1) &#123; cin&gt;&gt;k; add(d1,l,k),add(d1,r+1,-k),add(d2,l,k*l),add(d2,r+1,-k*(r+1)); &#125; else cout&lt;&lt;f(r)-f(l-1)&lt;&lt;endl; &#125; return 0; &#125; æœ€å€¼12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int m,n;int a[Max],c[Max],MAX[Max];char ch;inline int lowbit(int x)&#123;return x&amp;-x;&#125;void add(int p,int k)&#123; a[p]=k; while(p&lt;=n) &#123; c[p]=max(c[p],k); int t=lowbit(p); for(int i=1;i&lt;t;i*=2) c[p]=max(c[p],c[p-i]); p+=lowbit(p); &#125;&#125;int query(int l,int r)&#123; int ans=0; while(1) &#123; ans=max(ans,a[r]); if(r==l) break; for(r-=1;r-l&gt;=lowbit(r);r-=lowbit(r)) ans=max(ans,c[r]); &#125; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; pos(i,1,n) add(i,a[i]); int y,x; pos(i,1,m) &#123; ch=getchar(); while(ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=getchar(); scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); if(ch==&#x27;Q&#x27;) cout&lt;&lt;query(x,y)&lt;&lt;endl; else &#123; if(y&lt;=a[x]) continue; add(x,y); &#125; &#125; return 0;&#125; çº¿æ®µæ ‘123#define mid (s+((t-s)&gt;&gt;1))#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1) ä»¥ä¸‹ä»£ç ä¸­$s,t$ä»£è¡¨å½“å‰åŒºé—´$l,r$ä»£è¡¨è¯¢é—®åŒºé—´ åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=(t-s+1)*c; b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢123456789101112131415161718192021222324252627282930313233343536373839404142434445int n,m;int a[Max],d[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; // pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int x,int s,int t,int p,int c)&#123; if(s==t) &#123; d[p]+=c; return; &#125; // pushdown(s,t,p); if(x&lt;=mid) update(x,s,mid,ls,c); if(x&gt;mid) update(x,mid+1,t,rs,c); pushup(p);&#125; å•ç‚¹æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int x,int s,int t,int p)&#123; if(s==t) &#123; return d[p]; &#125; pushdown(s,t,p); if(x&lt;=mid) return query(x,s,mid,ls); if(x&gt;mid) return query(x,mid+1,t,rs);&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=c*(t-s+1); b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; ä¸»å¸­æ ‘ 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int cnt,n,m;int a[Max],root[Max];struct Tree&#123; int l,r,val;&#125;tree[Max];int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123; tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123; tree[p].val=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query(int p,int s,int t,int x)&#123; if(s==t) return tree[p].val; if(x&lt;=mid) return query(tree[p].l,s,mid,x); else return query(tree[p].r,mid+1,t,x);&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; root[0]=build(0,1,n); return 0;&#125; åŒºé—´ç¬¬kå°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; tree[cnt].val++; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123;// tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123;// tree[p].val+=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query1(int p,int q,int s,int t,int k)&#123; int x=tree[tree[p].l].val-tree[tree[q].l].val; if(s==t) return b[s]; if(x&gt;=k) return query1(tree[p].l,tree[q].l,s,mid,k); else return query1(tree[p].r,tree[q].r,mid+1,t,k-x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b+1,b+1+n); int nn=unique(b+1,b+1+n)-b-1; rt[0]=build(0,1,nn); for(int i=1;i&lt;=n;i++) &#123; int x=lower_bound(b+1,b+1+nn,a[i])-b; rt[i]=update(rt[i-1],1,nn,x,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; cout&lt;&lt;query1(rt[y],rt[x-1],1,nn,z)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"ä¸»å¸­æ ‘","slug":"ä¸»å¸­æ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"ä»åšå®¢å›­è½¬æ¥HEXO","slug":"ä»‹ç»","date":"2022-02-20T14:46:56.000Z","updated":"2022-02-21T05:42:30.770Z","comments":true,"path":"2022/02/20/ä»‹ç»/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/20/%E4%BB%8B%E7%BB%8D/","excerpt":"å¿ä¸äº†åœ¨åšå®¢å›­çš„é‚£ä¸ªäº† åœ¨ç½‘ä¸Šæ‰¾äº†ä¸ªæ•™ç¨‹è‡ªå·±æ­ä¸€ä¸ªhexoè¯•è¯• åé¢é™†ç»­ä¼šæ‰‹åŠ¨æŠŠç¬”è®°éƒ½æ¬è¿‡æ¥","text":"å¿ä¸äº†åœ¨åšå®¢å›­çš„é‚£ä¸ªäº† åœ¨ç½‘ä¸Šæ‰¾äº†ä¸ªæ•™ç¨‹è‡ªå·±æ­ä¸€ä¸ªhexoè¯•è¯• åé¢é™†ç»­ä¼šæ‰‹åŠ¨æŠŠç¬”è®°éƒ½æ¬è¿‡æ¥ åšå®¢å›­åŸå€","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://zhang2514yuchi.github.io/tags/dp/"},{"name":"é«˜ç²¾åº¦","slug":"é«˜ç²¾åº¦","permalink":"http://zhang2514yuchi.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"çº¿æ€§ä»£æ•°","slug":"çº¿æ€§ä»£æ•°","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"å¤§æ¨¡æ‹Ÿ","slug":"å¤§æ¨¡æ‹Ÿ","permalink":"http://zhang2514yuchi.github.io/tags/%E5%A4%A7%E6%A8%A1%E6%8B%9F/"},{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"http://zhang2514yuchi.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"åˆ†å—","slug":"åˆ†å—","permalink":"http://zhang2514yuchi.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"è«é˜Ÿ","slug":"è«é˜Ÿ","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"ä¸»å¸­æ ‘","slug":"ä¸»å¸­æ ‘","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]}