{"meta":{"title":"Juuichi","subtitle":"张宇驰的blog","description":"记录计算机相关知识,算法刷题笔记等","author":"Juuichi","url":"http://zhang2514yuchi.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-20T16:46:40.679Z","updated":"2022-02-20T16:46:40.669Z","comments":true,"path":"about/index.html","permalink":"http://zhang2514yuchi.github.io/about/index.html","excerpt":"","text":"我是 Juuichi 目前就读于 哈尔滨工程大学 退役ACMer"},{"title":"分类","date":"2022-02-21T04:34:53.000Z","updated":"2022-02-21T04:48:25.495Z","comments":true,"path":"categories/index.html","permalink":"http://zhang2514yuchi.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-21T04:33:30.000Z","updated":"2022-02-21T04:48:35.569Z","comments":true,"path":"tags/index.html","permalink":"http://zhang2514yuchi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小z的袜子[国家集训队]","slug":"P1494","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:12:11.169Z","comments":true,"path":"2022/02/21/P1494/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P1494/","excerpt":"","text":"复健一波莫队，发现最经典的模版竟然没做过 $\\$ 正好复习下这种简单的P1494 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int n,m,ans=0,block;int col[Max],a[Max];struct node&#123; int l,r,id;&#125;q[Max];struct node1&#123; int x,y;&#125;res[Max];int gcd(int a,int b)&#123;return b == 0 ? a:gcd(b,a%b);&#125;bool cmp(node a,node b)&#123; return (a.l/block)^(b.l/block)?(a.l/block)&lt;(b.l/block):(a.l/block)&amp;1?a.r&lt;b.r:a.r&gt;b.r;&#125;void add(int x)&#123; ans+=2*col[a[x]]+1; col[a[x]]++;&#125;void del(int x)&#123; ans+=1-2*col[a[x]]; col[a[x]]--;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; block=sqrt(n); for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q+1,q+1+m,cmp); int l=1,r=0; for(int i=1;i&lt;=m;i++) &#123; int ql=q[i].l,qr=q[i].r; while(ql&lt;l) add(--l); while(ql&gt;l) del(l++); while(qr&lt;r) del(r--); while(qr&gt;r) add(++r); int len=qr-ql+1; if(ans-len==0) &#123;res[q[i].id].x=0,res[q[i].id].y=1;continue;&#125; int t=gcd(ans-len,(len-1)*len); res[q[i].id].x=(ans-len)/t; res[q[i].id].y=(len-1)*len/t; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;res[i].x&lt;&lt;&quot;/&quot;&lt;&lt;res[i].y&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"P4513 小白逛公园","slug":"P4513","date":"2022-02-21T04:56:22.000Z","updated":"2022-02-21T05:04:22.825Z","comments":true,"path":"2022/02/21/P4513/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/P4513/","excerpt":"","text":"题意：序列，单点修改，询问区间最大子段和最大子段和指的是找出一个可以是空的子区间，和最大 著名的新手杀手题。。。其实也不难对于每个区间，维护一个最大前缀，最大后缀，以及区间内部的答案每次合并的时候，即答案选取左子区间的max，右子区间的max，或者左子区间的最大后缀+右子区间的最大前缀 P4513 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define int long long#define mid ((s+t)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs (ls+1)using namespace std;const int Max=5e5+10;int n,m;int a[Max];struct node&#123; int res,sum,lm,rm;&#125;d[Max*4]; void pushup(int p)&#123; d[p].sum=d[ls].sum+d[rs].sum; d[p].res=max(d[ls].rm+d[rs].lm,max(d[rs].res,d[ls].res)); if(d[rs].lm&gt;d[ls].lm-d[ls].sum) d[p].lm=d[ls].sum+d[rs].lm; else d[p].lm=d[ls].lm; if(d[ls].rm&gt;d[rs].rm-d[rs].sum) d[p].rm=d[rs].sum+d[ls].rm; else d[p].rm=d[rs].rm;&#125;void build(int p,int s,int t)&#123; if(s==t) &#123; d[p].sum=a[s]; d[p].lm=a[s]; d[p].rm=a[s]; d[p].res=a[s]; return; &#125; build(ls,s,mid); build(rs,mid+1,t); pushup(p);&#125;void update(int p,int s,int t,int x,int c)&#123; if(s==t) &#123; d[p].sum=c; d[p].res=c; d[p].lm=c; d[p].rm=c; return; &#125; if(x&lt;=mid) update(ls,s,mid,x,c); else update(rs,mid+1,t,x,c); pushup(p);&#125;node query(int p,int l,int r,int s,int t)&#123; if(l&lt;=s&amp;&amp;r&gt;=t) &#123; return d[p]; &#125; if(r&lt;=mid) return query(ls,l,r,s,mid); else if(l&gt;mid) return query(rs,l,r,mid+1,t); else &#123; auto x=query(ls,l,r,s,mid),y=query(rs,l,r,mid+1,t); node ans; ans.sum=x.sum+y.sum; ans.res=max(x.rm+y.lm,max(x.res,y.res)); if(y.lm&gt;x.lm-x.sum) ans.lm=x.sum+y.lm; else ans.lm=x.lm; if(x.rm&gt;y.rm-y.sum) ans.rm=y.sum+x.rm; else ans.rm=y.rm; return ans; &#125;&#125;signed main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(x==1) &#123; if(z&lt;y) swap(z,y); cout&lt;&lt;query(1,y,z,1,n).res&lt;&lt;&quot;\\n&quot;; &#125; else &#123; update(1,1,n,y,z); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-02-21T04:53:00.000Z","updated":"2022-02-21T05:14:29.348Z","comments":true,"path":"2022/02/21/数据结构/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"树状数组脑子里画出这个图 1.区间查&#x2F;单点改123456789101112131415int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125; 2.差分实现区间改&#x2F;单点查1234567891011121314151617181920212223242526272829303132333435363738int n,m;int c[Max],a[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123;cin&gt;&gt;a[i];add(i,a[i]-a[i-1]);&#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x; if(x==1) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; add(l,k),add(r+1,-k); &#125; else &#123; cin&gt;&gt;k; cout&lt;&lt;sum(k)&lt;&lt;endl; &#125; &#125; return 0; &#125; 3.差分实现区间改&#x2F;区间查$$sum[i]&#x3D;\\sum_{j&#x3D;1}^i c[j] \\times(i-j+1)\\sum[i]&#x3D;(i+1) \\times \\sum_{j&#x3D;1}^i c[j] -\\sum_{j&#x3D;1}^i c[j] \\times j$$ 123456789101112131415161718192021222324252627282930313233343536373839404142int n,m;int d1[Max],d2[Max],a[Max],b[Max];int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int *c,int p,int k)&#123; while(p&lt;=n)&#123;c[p]+=k;p+=lowbit(p);&#125;&#125;inline int sum(int *c,int p)&#123; int ans=0; while(p)&#123;ans+=c[p];p-=lowbit(p);&#125; return ans;&#125;inline int f(int x)&#123; return b[x]+(x+1)*sum(d1,x)-sum(d2,x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) &#123; cin&gt;&gt;a[i]; b[i]=b[i-1]+a[i]; &#125; pos(i,1,m) &#123; int x,l,r,k; cin&gt;&gt;x&gt;&gt;l&gt;&gt;r; if(x==1) &#123; cin&gt;&gt;k; add(d1,l,k),add(d1,r+1,-k),add(d2,l,k*l),add(d2,r+1,-k*(r+1)); &#125; else cout&lt;&lt;f(r)-f(l-1)&lt;&lt;endl; &#125; return 0; &#125; 4.最值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int m,n;int a[Max],c[Max],MAX[Max];char ch;inline int lowbit(int x)&#123;return x&amp;-x;&#125;void add(int p,int k)&#123; a[p]=k; while(p&lt;=n) &#123; c[p]=max(c[p],k); int t=lowbit(p); for(int i=1;i&lt;t;i*=2) c[p]=max(c[p],c[p-i]); p+=lowbit(p); &#125;&#125;int query(int l,int r)&#123; int ans=0; while(1) &#123; ans=max(ans,a[r]); if(r==l) break; for(r-=1;r-l&gt;=lowbit(r);r-=lowbit(r)) ans=max(ans,c[r]); &#125; return ans;&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; pos(i,1,n) add(i,a[i]); int y,x; pos(i,1,m) &#123; ch=getchar(); while(ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=getchar(); scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); if(ch==&#x27;Q&#x27;) cout&lt;&lt;query(x,y)&lt;&lt;endl; else &#123; if(y&lt;=a[x]) continue; add(x,y); &#125; &#125; return 0;&#125; 线段树123#define mid (s+((t-s)&gt;&gt;1))#define ls (p&lt;&lt;1)#define rs ((p&lt;&lt;1)|1) 以下代码中$s,t$代表当前区间$l,r$代表询问区间 区间修改，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=(t-s+1)*c; b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 单点修改，区间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445int n,m;int a[Max],d[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int l,int r,int s,int t,int p)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; return d[p]; &#125; int sum=0; // pushdown(s,t,p); if(l&lt;=mid) sum+=query(l,r,s,mid,ls); if(r&gt;mid) sum+=query(l,r,mid+1,t,rs); return sum;&#125;void update(int x,int s,int t,int p,int c)&#123; if(s==t) &#123; d[p]+=c; return; &#125; // pushdown(s,t,p); if(x&lt;=mid) update(x,s,mid,ls,c); if(x&gt;mid) update(x,mid+1,t,rs,c); pushup(p);&#125; 单点查询，区间修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int n,m;int a[Max],d[Max*4],b[Max*4];void pushup(int p)&#123; d[p]=d[ls]+d[rs];&#125;void pushdown(int s,int t,int p)&#123; if(b[p]!=0) &#123; b[ls]+=b[p],b[rs]+=b[p]; d[ls]+=b[p]*(mid+1-s); d[rs]+=b[p]*(t-mid); b[p]=0; &#125; return;&#125;void build(int s,int t,int p)&#123; if(s==t) &#123; d[p]=a[s]; return; &#125; build(s,mid,ls); build(mid+1,t,rs); pushup(p);&#125;int query(int x,int s,int t,int p)&#123; if(s==t) &#123; return d[p]; &#125; pushdown(s,t,p); if(x&lt;=mid) return query(x,s,mid,ls); if(x&gt;mid) return query(x,mid+1,t,rs);&#125;void update(int l,int r,int s,int t,int p,int c)&#123; if(l&lt;=s&amp;&amp;t&lt;=r) &#123; d[p]+=c*(t-s+1); b[p]+=c; return; &#125; pushdown(s,t,p); if(l&lt;=mid) update(l,r,s,mid,ls,c); if(r&gt;mid) update(l,r,mid+1,t,rs,c); pushup(p);&#125; 主席树$\\$ 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int cnt,n,m;int a[Max],root[Max];struct Tree&#123; int l,r,val;&#125;tree[Max];int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123; tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123; tree[p].val=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query(int p,int s,int t,int x)&#123; if(s==t) return tree[p].val; if(x&lt;=mid) return query(tree[p].l,s,mid,x); else return query(tree[p].r,mid+1,t,x);&#125;signed main()&#123; cin&gt;&gt;n&gt;&gt;m; pos(i,1,n) cin&gt;&gt;a[i]; root[0]=build(0,1,n); return 0;&#125; 区间第k小123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int clone(int p)&#123; cnt++; tree[cnt]=tree[p]; tree[cnt].val++; return cnt;&#125;int build(int p,int s,int t)&#123; p=++cnt; if(s==t) &#123;// tree[cnt].val=a[s]; return p; &#125; tree[p].l=build(tree[p].l,s,mid); tree[p].r=build(tree[p].r,mid+1,t); return p;&#125;int update(int p,int s,int t,int x,int v)&#123; p=clone(p); if(s==t) &#123;// tree[p].val+=v; return p; &#125; if(x&lt;=mid) tree[p].l=update(tree[p].l,s,mid,x,v); if(x&gt;mid) tree[p].r=update(tree[p].r,mid+1,t,x,v); return p;&#125;int query1(int p,int q,int s,int t,int k)&#123; int x=tree[tree[p].l].val-tree[tree[q].l].val; if(s==t) return b[s]; if(x&gt;=k) return query1(tree[p].l,tree[q].l,s,mid,k); else return query1(tree[p].r,tree[q].r,mid+1,t,k-x);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b+1,b+1+n); int nn=unique(b+1,b+1+n)-b-1; rt[0]=build(0,1,nn); for(int i=1;i&lt;=n;i++) &#123; int x=lower_bound(b+1,b+1+nn,a[i])-b; rt[i]=update(rt[i-1],1,nn,x,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; cout&lt;&lt;query1(rt[y],rt[x-1],1,nn,z)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"newpapername","slug":"介绍","date":"2022-02-20T14:46:56.000Z","updated":"2022-02-20T14:50:12.977Z","comments":true,"path":"2022/02/20/介绍/","link":"","permalink":"http://zhang2514yuchi.github.io/2022/02/20/%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"hello 我叫张宇驰 忍不了在博客园的那个了 在网上找了个教程自己搭一个hexo试试","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://zhang2514yuchi.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"http://zhang2514yuchi.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhang2514yuchi.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"主席树","slug":"主席树","permalink":"http://zhang2514yuchi.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]}